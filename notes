**************************** CS3520 General Notes ***********************************


Sections:

- Introduction and Plait
- How to Design Programs
- Interpreters
- Functions and Substitution
- Binding and Enviornments
- Functions as Values
- Mutable State
- Records
- Variables
- Encodings
- Encoding Recursion
- Recursion
- Lazy Evaluation
- Continuations
- Errors, Exceptions, call/cc
- Compilation
- Garbage Collection
- Objects
- Classes
- Types




Introduction and Plait **********************************************

__Class Demo__

#lang plait

(define-type Story
  (happy [text : String])
  (sad [text : String])
  (choice [text : String]
          [l : Story]
          [r : Story]))

;; Example Storys
(sad "The end")
(happy "They lived happily ever after")
(choice "Take programming languages?"
        (happy "They lived happily ever after")
        (sad "The end"))

(define (has-happy? [s : Story]) : Boolean
  (type-case Story s
    [(happy t) #t]
    [(sad t) #f]
    [(choice t l r) (or(has-happy? l)(has-happy? r))]))

(test (has-happy? (choice "Take programming languages?"
                          (happy "They lived happily ever after")
                          (sad "The end")))
      #t)
(test (has-happy? (choice "Take programming languages?"
                          (sad "They didn't live happily ever after")
                          (sad "The end")))
      #f)
______________


__NOTES__

interpreters - takes a program and produces a result.
compiler - takes a program and produces another program.

Racket is a programming language to develope other programming languages.

Dr Racket OPT-P to get previous run command (like R)

if statement -
(if (equal? "apple" "banana")
	'yes	; the then 
	'no)	; the else


How to Design Programs *********************************************************

__Class Demo__

#lang plait ;;;;;;;;;;;;;;

(print-only-errors #t)

(define-type Robot-ins
  (forward [feet : Number])
  (left)
  (right))

(define (amount-forward  [ins : Robot-ins])
  (type-case Robot-ins ins
    [(forward f) f]
    [(left) 0]
    [(right) 0]))

(test (amount-forward (forward 10))
      10)
(test (amount-forward (left))
      0)
(test (amount-forward (right))
      0)

;; ---

#;
(define-type (Listof Robot-ins)
  empty
  (cons [item : Robot-ins]
        [rst : (Listof Robot-ins)]))

(define (total-distance [inss : (Listof Robot-ins)])
  (type-case (Listof Robot-ins) inss
    [empty 0]
    [(cons item r) (+ (amount-forward item)
                      (total-distance r))]))

(test (total-distance empty)
      0)
(test (total-distance (cons (forward 4) (cons (left) empty)))
      4)

#lang plait ;;;;;;;;;;;;;;

(print-only-errors #t)

(define-type Robot-ins
  (forward [feet : Number])
  (left)
  (right))

(define (turn-or-not  [ins : Robot-ins])
  (type-case Robot-ins ins
    [(forward f) #f]
    [(left) #t]
    [(right) #t]))

(test (turn-or-not (forward 10))
       #f)
(test (turn-or-not (left))
      #t)
(test (turn-or-not (right))
      #t)

;; ---

#;
(define-type (Listof Robot-ins)
  empty
  (cons [item : Robot-ins]
        [rst : (Listof Robot-ins)]))

(define (is-turn? [inss : (Listof Robot-ins)])
  (type-case (Listof Robot-ins) inss
    [empty #f]
    [(cons item r) (or (turn-or-not item)
                       (is-turn? r))]))

(test (is-turn? (cons (forward 5) (cons (left) empty)))
      #t)
(test (is-turn? empty)
      #f)
(test (is-turn? (cons (forward 10) empty))
      #f)


#lang plait ;;;;;;;;;;;;;;;

(print-only-errors #t)

(define-type Robot-ins
  (forward [feet : Number])
  (left)
  (right))

(define (u-turn-or-not [prev : Robot-ins] [ins : Robot-ins])
  (type-case Robot-ins ins
    [(forward f) #f]
    [(left)
     (type-case Robot-ins prev
       [(left) #t]
       [else #f])]
    [(right)
     (type-case Robot-ins prev
       [(right) #t]
       [else #f])]))

;; In general, we have to try all possible combinations...

(test (u-turn-or-not (forward 4)
                     (forward 10))
      #f)
(test (u-turn-or-not (forward 4)
                     (left))
      #f)
(test (u-turn-or-not (forward 4)
                     (right))
      #f)

(test (u-turn-or-not (left)
                     (forward 10))
      #f)
(test (u-turn-or-not (left)
                     (left))
      #t)
(test (u-turn-or-not (left)
                     (right))
      #f)

(test (u-turn-or-not (right)
                     (forward 10))
      #f)
(test (u-turn-or-not (right)
                     (left))
      #f)
(test (u-turn-or-not (right)
                     (right))
      #t)

;; ---

#;
(define-type (Listof Robot-ins)
  empty
  (cons [item : Robot-ins]
        [rst : (Listof Robot-ins)]))

;; The `prev` argument acts as an accumulator

(define (any-u-turn? [inss : (Listof Robot-ins)]
                     [prev : Robot-ins])
  (type-case (Listof Robot-ins) inss
    [empty #f]
    [(cons item r) (or (u-turn-or-not prev item)
                       (any-u-turn? r item))]))


(test (any-u-turn? (cons (right) (cons (right) empty))
                   (forward 10))
      #t)
(test (any-u-turn? (cons (right) (cons (left) empty))
                   (right))
      #t)
(test (any-u-turn? (cons (right) (cons (left) empty))
                   (left))
      #f)
(test (any-u-turn? (cons (forward 5) (cons (left) empty))
                   (right))
      #f)
(test (any-u-turn? empty
                   (right))
      #f)
(test (any-u-turn? (cons (forward 10) empty)
                   (right))
      #f)


______________


__NOTES__

-How to desing a program (design recipe)
	Determine representaion
	Write examples (tests)
	Create a template
		typecase, extract fields, cross and self calls
	finish with body implementation case by case
	run tests
	--Aug 23 HtDP vids #6 and #7 to refresh--

-Function defintions should always match the data definition.
ex. 
	(define-type (Listof Number) ;The template has a self call in it
	  empty
	  (cons [n : Number]
	  		[rst : (Listof Number)]))  ; <- here Listof Number self call

	(define (feed-fish [lon : (Listof Number)]) ;Implementation should also have selfcall
		(type-case (Listof Number) lon
		  [empty empty]
		  [(cons n rst-lon)
		   (cons (+ 1 n)
		   		 (feed-fish rst-lon))])) ; <- here feed-fish self call


Interpreters *******************************************************

__Class Demo__

#lang plait
(print-only-errors #t)
(define-type Exp
  (numE [n : Number])
  (plusE [l :(Listof Exp)])
  (multE [l : Exp]
         [r : Exp])
  (diviE [l : Exp]
         [r : Exp])
  (absE [n : Exp]))

;; An EXP-S-EXP is either
;; - `NUMBER
;; - `{+ EXP-S-EXP ...}
;; - `{* EXP-S-EXP EXP-S-EXP}
;; - `{/ EXP-S-EXP EXP-S-EXP}
;; - `{abs EXP-S-EXP}

(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `{+ ANY ...} s)
     (plusE (map parse (rest (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{/ ANY ANY} s)
     (diviE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{abs ANY} s)
     (absE (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(test (parse `2)
      (numE 2))
(test (parse `{+ 2 1})
      (plusE (list (numE 2) (numE 1))))
(test (parse `{* 3 4})
      (multE (numE 3) (numE 4)))
(test (parse `{+ {* 3 4} 8})
      (plusE (list (multE (numE 3) (numE 4))
                   (numE 8))))
(test (parse `{+ {+ 7 3}})
      (plusE (list (plusE (list (numE 7) (numE 3))))))
(test/exn (parse `asdf)
          "invalid input") 
(test (parse `{/ 3 1})
      (diviE (numE 3) (numE 1)))
(test (parse `{abs 2})
      (absE (numE 2)))

(define (interp [a : Exp]) : Number
  (type-case Exp a
    [(numE n) n]
    [(plusE l) (sum-list l)]
    [(multE l r) (* (interp l) (interp r))]
    [(diviE l r) (/ (interp l) (interp r))]
    [(absE n)
     (local [(define v (interp n))]
       (cond
         [(< 0 v) v]
         [(>= 0 v) (- 0 v)]))]))

(define (sum-list [l : (Listof Exp)])
  (type-case (Listof Exp) l
    [empty 0]
    [(cons f r) (+ (interp f) (sum-list r))]))

(test (sum-list (list))
      0)
(test (sum-list (list (numE 1) (numE 2)))
      3)

(test (interp (numE 3))
      3)
(test (interp (parse `2))
      2)
(test (interp (parse `{+ 2 1}))
      3)
(test (interp (parse `{* 2 1}))
      2)
(test (interp (parse `{+ {* 2 3}
                         {+ 5 8}}))
      19)
(test (interp (plusE (list (multE (numE 2) (numE 3))
                           (plusE (list (numE 5) (numE 8))))))
      19)
(test (interp (parse `{/ 3 1}))
      3)
(test (interp (parse `{abs -2}))
      2)
(test (interp (parse `{abs 8}))
      8)
(test (interp (parse `{abs {+ -8 1}}))
      7)
(test (interp (parse `{+ 1 2 3 4}))
      10)
(test (interp (parse `{+ }))
      0)
(test (interp (parse `{+ 3}))
      3)

;; As long as the absE case doesn't interp its argument
;; multiple times, this deep nesting shouldn't take any
;; time:
(test (interp (parse `(abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs -10))))))))))))))))))))))
      10)

______________


__NOTES__

Plait - language we use to write our interpreters.
Curly - the language we keep making up to be interpreted.

Will use an S-expression ex. `{+ 1 2} so that plait doesnt evaluate the epression

Making sure you have tested your program enough - 
Dr. Racket -> choose language -> show details -> syntactic test coverage -> ok
	program will turn black and parts that havent run will be highlighted.

My thought process
1. Define the language and its grammar.
2. Write expressions of that language as S-Expressions.
3. Create parser to check if expressions are valid.
4. Use design recipe - 
	Determine the way we will represent the language in plait.
	Write examples.
	Create a template.
	Implement body.
	Run tests.
5. Run test coverage.


parsing to get abstract syntax

store the result of intrerp so we dont have to call it all the time
(local) [(define v (interp n))]

[(s-exp-match? `{+ ANY ...})] how to match zero or more ANY's
- have a list of s-expersions -> want a list of expressions - one to one function
- use map -> (plusE (map (parse (rest (s-exp->list s)))))


Functions and Substitution ******************************************************

__Class Demo__

#lang plait

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (multE [l : Exp]
         [r : Exp])
  (appE [s : Symbol]
        [arg : Exp])
  (abs-val [ex : Exp])
  (if-zeroE [ex : Exp]
            [thn : Exp]
            [els : Exp]))

(define-type Func-Defn
  (fd [name : Symbol] 
      [arg : Symbol] 
      [body : Exp]))

(module+ test
  (print-only-errors #t))

;; An EXP is either
;; - `NUMBER
;; - `SYMBOL
;; - `{+ EXP EXP}
;; - `{* EXP EXP}
;; - `{SYMBOL EXP)

;; A FUNC-DEFN is
;; - `{define {SYMBOL SYMBOL} EXP}

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{abs ANY} s)
     (abs-val (parse (second (s-exp->list s))))]
    [(s-exp-match? `{SYMBOL ANY} s)
     (appE (s-exp->symbol (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [(s-exp-match? `{if0 ANY ANY ANY} s)
     (if-zeroE (parse (second (s-exp->list s)))
               (parse (third (s-exp->list s)))
               (parse (fourth (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(define (parse-fundef [s : S-Exp]) : Func-Defn
  (cond
    [(s-exp-match? `{define {SYMBOL SYMBOL} ANY} s)
     (fd (s-exp->symbol (first (s-exp->list (second (s-exp->list s)))))
         (s-exp->symbol (second (s-exp->list (second (s-exp->list s)))))
         (parse (third (s-exp->list s))))]
    [else (error 'parse-fundef "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x)
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (multE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{double 9})
        (appE 'double (numE 9)))
  (test (parse `{abs -1})
        (abs-val (numE -1)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input")

  (test (parse-fundef `{define {double x} {+ x x}})
        (fd 'double 'x (plusE (idE 'x) (idE 'x))))
  (test/exn (parse-fundef `{def {f x} x})
            "invalid input")

  (define double-def
    (parse-fundef `{define {double x} {+ x x}}))
  (define quadruple-def
    (parse-fundef `{define {quadruple x} {double {double x}}})))

;; interp ----------------------------------------
(define (interp [a : Exp] [defs : (Listof Func-Defn)]) : Number
  (type-case Exp a
    [(numE n) n]
    [(idE s) (error 'interp "free variable")]
    [(plusE l r) (+ (interp l defs) (interp r defs))]
    [(multE l r) (* (interp l defs) (interp r defs))]
    [(appE s arg) (local [(define fd (get-fundef s defs))]
                    (interp (subst (numE (interp arg defs))
                                   (fd-arg fd)
                                   (fd-body fd))
                            defs))]
    [(abs-val s) (local [(define result (interp s defs))]
                   (if (< result 0)
                       (* -1 result)
                       result))]
    [(if-zeroE ex thn els) (if (equal? 0 (interp ex defs))
                               (interp thn defs)
                               (interp els defs))]))

(module+ test
  (test (interp (parse `2) empty)
        2)
  (test/exn (interp (parse `x) empty)
            "free variable")
  (test (interp (parse `{+ 2 1}) empty)
        3)
  (test (interp (parse `{* 2 1}) empty)
        2)
  (test (interp (parse `{+ {* 2 3}
                           {+ 5 8}})
                empty)
        19)
  (test (interp (parse `{double 8})
                (list double-def))
        16)
  (test (interp (parse `{quadruple 8})
                (list double-def quadruple-def))
        32)
  (test (interp (parse `{abs -1})
                empty)
        1)

  (test (interp (parse `{abs {f 3}})
                (list (parse-fundef `{define {f x} {+ x 1}})))
        4)

  (test (interp (parse `{f 3})
                (list (parse-fundef `{define {f x} {+ {abs x} 1}})))
        4)
  (test (interp (parse `{if0 0 1 2})
                empty)
        1)
  (test (interp (parse `{if0 1 1 2})
                empty)
        2)
  (test (interp (parse `{f 3})
                (list (parse-fundef `{define {f x} {if0 x 2 x}})))
        3))

;; get-fundef ----------------------------------------
(define (get-fundef [s : Symbol] [defs : (Listof Func-Defn)]) : Func-Defn
  (type-case (Listof Func-Defn) defs
    [empty (error 'get-fundef "undefined function")]
    [(cons def rst-defs) (if (eq? s (fd-name def))
                             def
                             (get-fundef s rst-defs))]))

(module+ test
  (test (get-fundef 'double (list double-def))
        double-def)
  (test (get-fundef 'double (list double-def quadruple-def))
        double-def)
  (test (get-fundef 'double (list quadruple-def double-def))
        double-def)
  (test (get-fundef 'quadruple (list quadruple-def double-def))
        quadruple-def)
  (test/exn (get-fundef 'double empty)
            "undefined function"))

;; subst ----------------------------------------
(define (subst [what : Exp] [for : Symbol] [in : Exp])
  (type-case Exp in
    [(numE n) in]
    [(idE s) (if (eq? for s)
                 what
                 in)]
    [(plusE l r) (plusE (subst what for l)
                        (subst what for r))]
    [(multE l r) (multE (subst what for l)
                        (subst what for r))]
    [(appE s arg) (appE s (subst what for arg))]
    [(abs-val s)  (abs-val (subst what for s))]
    [(if-zeroE ex thn els)
     (if-zeroE (subst what for ex)
               (subst what for thn)
               (subst what for els))]))


(module+ test
  (test (subst (numE 8) 'x (numE 9))
        (numE 9))
  (test (subst (numE 8) 'x (idE 'x))
        (numE 8))
  (test (subst (numE 8) 'x (idE 'y))
        (idE 'y))
  (test (subst (numE 8) 'x (plusE (idE 'x) (idE 'y)))
        (plusE (numE 8) (idE 'y)))
  (test (subst (numE 8) 'x (multE (idE 'y) (idE 'x)))
        (multE (idE 'y) (numE 8)))
  (test (subst (numE 8) 'x (appE 'double (idE 'x)))
        (appE 'double (numE 8))))

(module+ test
  (test (subst (parse `8) 'x (parse `9))
        (numE 9))
  (test (subst (parse `8) 'x (parse `x))
        (numE 8))
  (test (subst (parse `8) 'x (parse `y))
        (idE 'y))
  (test (subst (parse `8) 'x (parse `{+ x y}))
        (parse `{+ 8 y}))
  (test (subst (parse `8) 'x (parse `{* y x}))
        (parse `{* y 8}))
  (test (subst (parse `8) 'x (parse `{double x}))
        (parse `{double 8}))
  (test (subst (parse `1) 'x (parse `{abs x}))
        (parse `{abs 1})))

______________


__NOTES__

Functions:
- a name
- an argument name
- a body

function definitions are not expressions.

interpreting functions:
- interp : (Exp (Listof Func-Defn) -> Number) ;; still want to interpret the function
- get-fundef : (Symbol (Listof Func-Defn) -> Func-Defn) ;; need to know what the function is
- subst : (Exp Symbol Exp -> Exp) ;; substitute the funciton with its body

* Follow design recipe *


Binding and Environments *********************************************

__Class Demo__

#lang plait

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [arg : (Listof Exp)]) 
  (multE [l : Exp]
         [r : Exp])
  (appE [s : Symbol]
        [arg : Exp])
  (letE [n : Symbol] 
        [rhs : Exp]
        [body : Exp]))



(define-type Func-Defn
  (fd [name : Symbol] 
      [arg : Symbol] 
      [body : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [val : Number]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ...} s)
     (plusE (parse-list (rest (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{SYMBOL ANY} s)
     (appE (s-exp->symbol (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (letE (s-exp->symbol (first bs))
             (parse (second bs))
             (parse (third (s-exp->list s)))))]
    [else (error 'parse "invalid input")]))

(define (parse-list [i : (Listof S-Exp)]) : (Listof Exp)
  (type-case (Listof S-Exp) i
    [empty empty]
    [(cons f r) (cons (parse f) (parse-list r))]))
  
(module+ test
  (test (parse-list empty)
        empty)
  (test (parse-list (list `1))
        (list (numE 1)))
  (test (parse-list (list `1 `2))
        (list (numE 1) (numE 2))))
                  
  
(define (parse-fundef [s : S-Exp]) : Func-Defn
  (cond
    [(s-exp-match? `{define {SYMBOL SYMBOL} ANY} s)
     (fd (s-exp->symbol (first (s-exp->list (second (s-exp->list s)))))
         (s-exp->symbol (second (s-exp->list (second (s-exp->list s)))))
         (parse (third (s-exp->list s))))]
    [else (error 'parse-fundef "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x) ; note: backquote instead of normal quote
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (list (numE 2) (numE 1))))
  (test (parse `{+})
        (plusE empty))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (list (multE (numE 3) (numE 4))
               (numE 8))))
  (test (parse `{double 9})
        (appE 'double (numE 9)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (letE 'x (plusE (list (numE 1) (numE 2)))
              (idE 'y)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input")
  (test (parse `{+ 1 2 3})
      (plusE (list (numE 1) (numE 2) (numE 3))))

  (test (parse-fundef `{define {double x} {+ x x}})
        (fd 'double 'x (plusE (list (idE 'x) (idE 'x)))))
  (test/exn (parse-fundef `{def {f x} x})
            "invalid input")

  (define double-def
    (parse-fundef `{define {double x} {+ x x}}))
  (define quadruple-def
    (parse-fundef `{define {quadruple x} {double {double x}}})))

;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env] [fds : (Listof Func-Defn)]) : Number
  (type-case Exp a
    [(numE n) n]
    [(idE s) (lookup s env)]
    [(plusE l) (interp-and-sum-list l env fds)]
    [(multE l r) (* (interp l env fds) (interp r env fds))]
    [(appE s arg) (local [(define fd (get-fundef s fds))]
                    (interp (fd-body fd)
                            (extend-env
                             (bind (fd-arg fd)
                                   (interp arg env fds))
                             mt-env)
                            fds))]
    [(letE n rhs body)
     (interp body
             (extend-env 
              (bind n (interp rhs env fds))
              env)
             fds)]))

(define (interp-and-sum-list [i : (Listof Exp)] [env : Env] [fds : (Listof Func-Defn)]) : Number
  (type-case (Listof Exp) i
    [empty 0]
    [(cons f r) (+ (interp f env fds) (interp-and-sum-list r env fds))]))

(module+ test
  (test (interp (parse `2) mt-env empty)
        2)
  (test/exn (interp (parse `x) mt-env empty)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x 9) mt-env)
                empty)
        9)
  (test (interp (parse `{+ 2 1}) mt-env empty)
        3)
  (test (interp (parse `{* 2 1}) mt-env empty)
        2)
  (test (interp (parse `{+ {* 2 3} {+ 5 8}})
                mt-env
                empty)
        19)
  (test (interp (parse `{double 8})
                mt-env
                (list double-def))
        16)
  (test (interp (parse `{quadruple 8})
                mt-env
                (list double-def quadruple-def))
        32)
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env
                empty)
        10)
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env
                empty)
        12)
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env
                empty)
        5)
  (test/exn (interp (parse `{let {[y 5]}
                              {bad 2}})
                    mt-env
                    (list (parse-fundef `{define {bad x} {+ x y}})))
            "free variable"))

;; get-fundef ----------------------------------------
(define (get-fundef [s : Symbol] [defs : (Listof Func-Defn)]) : Func-Defn
  (type-case (Listof Func-Defn) defs
    [empty (error 'get-fundef "undefined function")]
    [(cons def rst-defs) (if (eq? s (fd-name def))
                             def
                             (get-fundef s rst-defs))]))

(module+ test
  (test (get-fundef 'double (list double-def))
        double-def)
  (test (get-fundef 'double (list double-def quadruple-def))
        double-def)
  (test (get-fundef 'double (list quadruple-def double-def))
        double-def)
  (test (get-fundef 'quadruple (list quadruple-def double-def))
        quadruple-def)
  (test/exn (get-fundef 'double empty)
            "undefined function"))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Number
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-val b)]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x 8) mt-env))
        8)
  (test (lookup 'x (extend-env
                    (bind 'x 9)
                    (extend-env (bind 'x 8) mt-env)))
        9)
  (test (lookup 'y (extend-env
                    (bind 'x 9)
                    (extend-env (bind 'y 8) mt-env)))
        8))
  
______________


__Notes__

Backus-Naur Form (BNF) - more standard way to represent curly grammar.
Keyword let binds name to closest

binding - where an identifier gets its meaning
ex. 	'x' is binding
	{let {['x' 5]} ....}
	{define {f 'x'} ....}

bound - refers to a binding
ex. 	'x' is bound
	{let {[x 5]} .... 'x' ....}
	{define {f x} .... 'x' ....}

free - does not have a binding
ex. 	'y' is free
	{let {[x 5]} .... 'y' ....}
	{define {f x} .... 'y' ....}

Substitution replaces all of the free identifiers.
Variables and function names are thought of this way.


Functions as Values *********************************************

__Class Demo__

functions_as_values_demo file ;trace calls to interp
______________

__Notes__

Closure: combine expression with an enviornment

(trace interp) :show me all args and results of every call to interp

menu -> submodules to run -> turn off tests


Mutable State *****************************************************

__Class Demo__

#lang plait

;; Start with "store-with.rkt"
;;
;; * Add {swap expr expr}

(define-type-alias Location Number)

(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env])
  (boxV [l : Location]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (multE [l : Exp]
         [r : Exp])
  (letE [n : Symbol] 
        [rhs : Exp]
        [body : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (swapE [l : Exp]
         [r : Exp])
  (appE [fun : Exp]
        [arg : Exp])
  (boxE [arg : Exp])
  (unboxE [arg : Exp])
  (setboxE [bx : Exp]
           [val : Exp])
  (beginE [l : Exp]
          [r : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [val : Value]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(define-type Storage
  (cell [location : Location] 
        [val : Value]))

(define-type-alias Store (Listof Storage))
(define mt-store empty)
(define override-store cons)

(define-type Result
  (v*s [v : Value] [s : Store]))

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (letE (s-exp->symbol (first bs))
             (parse (second bs))
             (parse (third (s-exp->list s)))))]
    [(s-exp-match? `{swap ANY ANY} s)
     (swapE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{box ANY} s)
     (boxE (parse (second (s-exp->list s))))]
    [(s-exp-match? `{unbox ANY} s)
     (unboxE (parse (second (s-exp->list s))))]
    [(s-exp-match? `{set-box! ANY ANY} s)
     (setboxE (parse (second (s-exp->list s)))
              (parse (third (s-exp->list s))))]
    [(s-exp-match? `{begin ANY ANY} s)
     (beginE (parse (second (s-exp->list s)))
             (parse (third (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x)
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (multE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (letE 'x (plusE (numE 1) (numE 2))
              (idE 'y)))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test (parse `{box 0})
        (boxE (numE 0)))
  (test (parse `{unbox b})
        (unboxE (idE 'b)))
  (test (parse `{set-box! b 0})
        (setboxE (idE 'b) (numE 0)))
  (test (parse `{begin 1 2})
        (beginE (numE 1) (numE 2)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; with form ----------------------------------------
(define-syntax-rule
  (with [(v-id sto-id) call]
    body)
  (type-case Result call
    [(v*s v-id sto-id) body]))
                                
;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env] [sto : Store]) : Result
  (type-case Exp a
    [(numE n) (v*s (numV n) sto)]
    [(idE s) (v*s (lookup s env) sto)]
    [(plusE l r)
     (with [(v-l sto-l) (interp l env sto)]
       (with [(v-r sto-r) (interp r env sto-l)]
         (v*s (num+ v-l v-r) sto-r)))]
    [(multE l r)
     (with [(v-l sto-l) (interp l env sto)]
       (with [(v-r sto-r) (interp r env sto-l)]
         (v*s (num* v-l v-r) sto-r)))]
    [(letE n rhs body)
     (with [(v-rhs sto-rhs) (interp rhs env sto)]
       (interp body
               (extend-env
                (bind n v-rhs)
                env)
               sto-rhs))]
    [(lamE n body)
     (v*s (closV n body env) sto)]
    [(swapE l r)
     (with [(left-v left-sto) (interp l env sto)]
           (type-case Value left-v
             [(boxV left-loc)
              (with [(right-v right-sto) (interp r env left-sto)]
                    (type-case Value right-v
                      [(boxV right-loc)
                       (let ([lft-tmp (fetch left-loc right-sto)])
                         (let ([rght-tmp (fetch right-loc right-sto)])
                           (v*s (numV 0) (override-store (cell right-loc lft-tmp)
                                           (override-store (cell left-loc rght-tmp)
                                                           right-sto)))))]
                                            
                      [else (error 'interp "not a box")]))]
             [else (error 'interp "not a box")]))]
    [(appE fun arg)
     (with [(v-f sto-f) (interp fun env sto)]
       (with [(v-a sto-a) (interp arg env sto-f)]
         (type-case Value v-f
           [(closV n body c-env)
            (interp body
                    (extend-env
                     (bind n v-a)
                     c-env)
                    sto-a)]
           [else (error 'interp "not a function")])))]
    [(boxE a)
     (with [(v sto-v) (interp a env sto)]
       (let ([l (new-loc sto-v)])
         (v*s (boxV l) 
              (override-store (cell l v) 
                              sto-v))))]
    [(unboxE a)
     (with [(v sto-v) (interp a env sto)]
       (type-case Value v
         [(boxV l) (v*s (fetch l sto-v) 
                        sto-v)]
         [else (error 'interp "not a box")]))]
    [(setboxE bx val)
     (with [(v-b sto-b) (interp bx env sto)]
       (with [(v-v sto-v) (interp val env sto-b)]
         (type-case Value v-b
           [(boxV l)
            (v*s v-v
                 (override-store (cell l v-v)
                                 sto-v))]
           [else (error 'interp "not a box")])))]
    [(beginE l r)
     (with [(v-l sto-l) (interp l env sto)]
       (interp r env sto-l))]))

(module+ test
  (test (interp (parse `2) mt-env mt-store)
        (v*s (numV 2) 
             mt-store))
  (test/exn (interp (parse `x) mt-env mt-store)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x (numV 9)) mt-env)
                mt-store)
        (v*s (numV 9)
             mt-store))
  (test (interp (parse `{+ 2 1}) mt-env mt-store)
        (v*s (numV 3)
             mt-store))
  (test (interp (parse `{* 2 1}) mt-env mt-store)
        (v*s (numV 2)
             mt-store))
  (test (interp (parse `{+ {* 2 3} {+ 5 8}})
                mt-env
                mt-store)
        (v*s (numV 19)
             mt-store))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env
                mt-store)
        (v*s (closV 'x (plusE (idE 'x) (idE 'x)) mt-env)
             mt-store))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env
                mt-store)
        (v*s (numV 10)
             mt-store))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env
                mt-store)
        (v*s (numV 12)
             mt-store))
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env
                mt-store)
        (v*s (numV 5)
             mt-store))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env
                mt-store)
        (v*s (numV 16)
             mt-store))
  (test (interp (parse `{box 5})
                mt-env
                mt-store)
        (v*s (boxV 1)
             (override-store (cell 1 (numV 5))
                             mt-store)))
  (test (interp (parse `{unbox {box 5}})
                mt-env
                mt-store)
        (v*s (numV 5)
             (override-store (cell 1 (numV 5))
                             mt-store)))
  (test (interp (parse `{set-box! {box 5} 6})
                mt-env
                mt-store)
        (v*s (numV 6)
             (override-store (cell 1 (numV 6))
                             (override-store (cell 1 (numV 5))
                                             mt-store))))
  (test (interp (parse `{begin 1 2})
                mt-env
                mt-store)
        (v*s (numV 2)
             mt-store))
  (test (interp (parse `{let {[b (box 5)]}
                          {begin
                            {set-box! b 6}
                            {unbox b}}})
                mt-env
                mt-store)
        (v*s (numV 6)
             (override-store (cell 1 (numV 6))
                             (override-store (cell 1 (numV 5))
                                             mt-store))))

  (test/exn (interp (parse `{1 2}) mt-env mt-store)
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env mt-store)
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env
                    mt-store)
            "free variable"))

;; num+ and num* ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num* [l : Value] [r : Value]) : Value
  (num-op * l r))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num* (numV 2) (numV 3))
        (numV 6)))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Value
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-val b)]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x (numV 8)) mt-env))
        (numV 8))
  (test (lookup 'x (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'x (numV 8)) mt-env)))
        (numV 9))
  (test (lookup 'y (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'y (numV 8)) mt-env)))
        (numV 8)))
  
;; store operations ----------------------------------------

(define (new-loc [sto : Store]) : Location
  (+ 1 (max-address sto)))

(define (max-address [sto : Store]) : Location
  (type-case (Listof Storage) sto
   [empty 0]
   [(cons c rst-sto) (max (cell-location c)
                          (max-address rst-sto))]))

(define (fetch [l : Location] [sto : Store]) : Value
  (type-case (Listof Storage) sto
   [empty (error 'interp "unallocated location")]
   [(cons c rst-sto) (if (equal? l (cell-location c))
                         (cell-val c)
                         (fetch l rst-sto))]))

(module+ test
  (test (max-address mt-store)
        0)
  (test (max-address (override-store (cell 2 (numV 9))
                                     mt-store))
        2)
  
  (test (fetch 2 (override-store (cell 2 (numV 9))
                                 mt-store))
        (numV 9))
  (test (fetch 2 (override-store (cell 2 (numV 10))
                                 (override-store (cell 2 (numV 9))
                                                 mt-store)))
        (numV 10))
  (test (fetch 3 (override-store (cell 2 (numV 10))
                                 (override-store (cell 3 (numV 9))
                                                 mt-store)))
        (numV 9))
  (test/exn (fetch 2 mt-store)
            "unallocated location"))

(module+ test
  (test (interp (parse `{let {[a {box 1}]}
                          {let {[b {box 2}]}
                            {begin
                              {swap a b}
                              {unbox a}}}})
                mt-env
                mt-store)
        (v*s (numV 2) (list (cell 2 (numV 1))
                            (cell 1 (numV 2))
                            (cell 2 (numV 2))
                            (cell 1 (numV 1))))))
______________

__Notes__

Avoiding states makes it easy to check like the aquarium example you check the old list with the new list and not how the old list has changed. Avoiding state also dosent destroy the old list so you can compare the old list to a new list. 

you need state when you code is part of a larger project where you dont have access to all the communicaiton channels so some state must be kept to interact.

State gives a way to add a side channel to a program. A function can affect a later call to another function without passing that information along.

***Store passing programming style - passing the state of the program around.



Records ********************************************************

__Class Demo__

#lang plait ;;;;;;;;;;;;;;;;

;; Define `dist` and `swap` functions in Curly

;; Add an {add <exp> <name> <exp>} form to add a field
;; to a record

(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env])
  (recV [ns : (Listof Symbol)]
        [vs : (Listof Value)]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (multE [l : Exp]
         [r : Exp])
  (letE [n : Symbol] 
        [rhs : Exp]
        [body : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (addE [rec : Exp]
        [name : Symbol]
        [val : Exp])
  (appE [fun : Exp]
        [arg : Exp])
  (recordE [ns : (Listof Symbol)]
           [args : (Listof Exp)])
  (getE [rec : Exp]
        [n : Symbol])
  (setE [rec : Exp]
        [n : Symbol]
        [val : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [val : Value]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (letE (s-exp->symbol (first bs))
             (parse (second bs))
             (parse (third (s-exp->list s)))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]

    [(s-exp-match? `{record {SYMBOL ANY} ...} s)
     (recordE (map (lambda (l) (s-exp->symbol (first (s-exp->list l))))
                   (rest (s-exp->list s)))
              (map (lambda (l) (parse (second (s-exp->list l))))
                   (rest (s-exp->list s))))]
    [(s-exp-match? `{get ANY SYMBOL} s)
     (getE (parse (second (s-exp->list s)))
           (s-exp->symbol (third (s-exp->list s))))]
    [(s-exp-match? `{set ANY SYMBOL ANY} s)
     (setE (parse (second (s-exp->list s)))
           (s-exp->symbol (third (s-exp->list s)))
           (parse (fourth (s-exp->list s))))]
   [(s-exp-match? `{add ANY SYMBOL ANY} s)
     (addE (parse (second (s-exp->list s)))
           (s-exp->symbol (third (s-exp->list s)))
           (parse (fourth (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x)
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (multE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (letE 'x (plusE (numE 1) (numE 2))
              (idE 'y)))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test (parse `{record {x 2} {y 3}})
        (recordE (list 'x 'y)
                 (list (numE 2) (numE 3))))
  (test (parse `{get {+ 1 2} a})
        (getE (plusE (numE 1) (numE 2)) 'a))
  (test (parse `{set {+ 1 2} a 7})
        (setE (plusE (numE 1) (numE 2)) 'a (numE 7)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env]) : Value
  (type-case Exp a
    [(numE n) (numV n)]
    [(idE s) (lookup s env)]
    [(plusE l r) (num+ (interp l env) (interp r env))]
    [(multE l r) (num* (interp l env) (interp r env))]
    [(letE n rhs body)
          (interp body
                  (extend-env
                   (bind n (interp rhs env))
                   env))]
    [(addE r n v)  
     (type-case Value (interp r env)
       [(recV ns vs) (if (member n ns)
                         (error 'interp "field already there")
                         (recV (append ns (list n))
                               (append vs (list (interp v env)))))]
       [else (error 'interp "not a record")])]
    [(lamE n body) (closV n body env)]
    [(appE fun arg) (type-case Value (interp fun env)
                      [(closV n body c-env)
                             (interp body
                                     (extend-env
                                      (bind n
                                            (interp arg env))
                                      c-env))]
                      [else (error 'interp "not a function")])]
    [(recordE ns as)
     (recV ns
           (map (lambda (a) (interp a env))
                as))]
    [(getE a n)
     (type-case Value (interp a env)
       [(recV ns vs) (find n ns vs)]
       [else (error 'interp "not a record")])]
    [(setE a n v)
     (type-case Value (interp a env)
       [(recV ns vs)
        (recV ns (update n (interp v env) ns vs))]
       [else (error 'interp "not a record")])]))

(module+ test
  (test (interp (parse `2) mt-env)
        (numV 2))
  (test/exn (interp (parse `x) mt-env)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x (numV 9)) mt-env))
        (numV 9))
  (test (interp (parse `{+ 2 1}) mt-env)
        (numV 3))
  (test (interp (parse `{* 2 1}) mt-env)
        (numV 2))
  (test (interp (parse `{+ {* 2 3} {+ 5 8}})
                mt-env)
        (numV 19))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env)
        (closV 'x (plusE (idE 'x) (idE 'x)) mt-env))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env)
        (numV 10))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env)
        (numV 12))
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env)
        (numV 5))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env)
        (numV 16))

  (test (interp (parse `{record {a {+ 1 1}}
                                {b {+ 2 2}}})
                mt-env)
        (recV (list 'a 'b) 
              (list (numV 2) (numV 4))))
  (test (interp (parse `{get {record {a {+ 1 1}}
                                     {b {+ 2 2}}} a})
                mt-env)
        (numV 2))
  (test (interp (parse `{get {record {a {+ 1 1}}
                                     {b {+ 2 2}}} b})
                mt-env)
        (numV 4))
  (test (interp (parse `{set {record {a {+ 1 1}}
                                     {b {+ 2 2}}} a 5})
                mt-env)
        (recV (list 'a 'b) 
              (list (numV 5) (numV 4))))
  (test (interp (parse `{let {[r1 {record {a {+ 1 1}}
                                          {b {+ 2 2}}}]}
                          {let {[r2 {set r1 a 5}]}
                            {+ {get r1 a} {get r2 a}}}})
                mt-env)
        (numV 7))

  (test/exn (interp (parse `{1 2}) mt-env)
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env)
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env)
            "free variable")
  (test/exn (interp (parse `{get 6 x}) mt-env)
            "not a record")
  (test/exn (interp (parse `{set 6 x 9}) mt-env)
            "not a record"))

;; num+ and num* ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num* [l : Value] [r : Value]) : Value
  (num-op * l r))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num* (numV 2) (numV 3))
        (numV 6)))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Value
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-val b)]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x (numV 8)) mt-env))
        (numV 8))
  (test (lookup 'x (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'x (numV 8)) mt-env)))
        (numV 9))
  (test (lookup 'y (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'y (numV 8)) mt-env)))
        (numV 8)))
  
;; find & update ----------------------------------------

;; Takes a name and two parallel lists, returning an item from the
;; second list where the name matches the item from the first list.
(define (find [n : Symbol] [ns : (Listof Symbol)] [vs : (Listof Value)])
  : Value
  (cond
   [(empty? ns) (error 'interp "no such field")]
   [else (if (symbol=? n (first ns))
             (first vs)
             (find n (rest ns) (rest vs)))]))

;; Takes a name n, value v, and two parallel lists, returning a list
;; like the second of the given lists, but with v in place
;; where n matches the item from the first list.
(define (update [n : Symbol]
                [v : Value]
                [ns : (Listof Symbol)]
                [vs : (Listof Value)]) : (Listof Value)
  (cond
    [(empty? ns) (error 'interp "no such field")]
    [else (if (symbol=? n (first ns))
              (cons v (rest vs))
              (cons (first vs) 
                    (update n v (rest ns) (rest vs))))]))


(module+ test
  (test (find 'a (list 'a 'b) (list (numV 1) (numV 2)))
        (numV 1))
  (test (find 'b (list 'a 'b) (list (numV 1) (numV 2)))
        (numV 2))
  (test/exn (find 'a empty empty)
            "no such field")

  (test (update 'a (numV 0) (list 'a 'b) (list (numV 1) (numV 2)))
        (list (numV 0) (numV 2)))
  (test (update 'b (numV 0) (list 'a 'b) (list (numV 1) (numV 2)))
        (list (numV 1) (numV 0)))
  (test/exn (update 'a (numV 0) empty empty)
            "no such field")
  (test (interp (parse `{let {[dist {lambda {r}
                                      {+ {get r x} {get r y}}}]}
                          {dist {record {x 1} {y 2}}}}
                          )
                mt-env)
        (numV 3))
  
  (test (interp (parse `{let {[swap {lambda {r}
                                      {let {[r_x {get r x}]}
                                        {let {[r_y {get r y}]}
                                          {record {x r_y} {y r_x}}}}}]}
                          {swap {record {x 2} {y 3} {z 4}}}})
                mt-env)
        (recV (list 'x 'y) (list (numV 3) (numV 2))))
  
  (test (interp (parse `{let {[swap {lambda {r}
                                      {let {[r_x {get r x}]}
                                        {let {[r_y {get r y}]}
                                          {set {set r x r_y} y r_x}}}}]}
                          {swap {record {x 2} {y 3} {z 4}}}})
                mt-env)
        (recV (list 'x 'y 'z) (list (numV 3) (numV 2) (numV 4))))
  
  (test (interp (parse `{let {[swap {lambda {r}
                                      {set {set r x {get r y}} y {get r x}}}]}
                          {swap {record {x 2} {y 3} {z 4}}}})
                mt-env)
        (recV (list 'x 'y 'z) (list (numV 3) (numV 2) (numV 4))))) 


  
 #lang plait ;;;;;;;;;;;;;;;;;;

;; Define a `swap!` function in Curly

(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env])
  (recV [ns : (Listof Symbol)]
        [vs : (Listof (Boxof Value))]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (multE [l : Exp]
         [r : Exp])
  (letE [n : Symbol] 
        [rhs : Exp]
        [body : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun : Exp]
        [arg : Exp])
  (recordE [ns : (Listof Symbol)]
           [args : (Listof Exp)])
  (getE [rec : Exp]
        [n : Symbol])
  (setE [rec : Exp]
        [n : Symbol]
        [val : Exp])
  (beginE [l : Exp]
          [r : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [val : Value]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (letE (s-exp->symbol (first bs))
             (parse (second bs))
             (parse (third (s-exp->list s)))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]

    [(s-exp-match? `{record {SYMBOL ANY} ...} s)
     (recordE (map (lambda (l) (s-exp->symbol (first (s-exp->list l))))
                   (rest (s-exp->list s)))
              (map (lambda (l) (parse (second (s-exp->list l))))
                   (rest (s-exp->list s))))]
    [(s-exp-match? `{get ANY SYMBOL} s)
     (getE (parse (second (s-exp->list s)))
           (s-exp->symbol (third (s-exp->list s))))]
    [(s-exp-match? `{set! ANY SYMBOL ANY} s)
     (setE (parse (second (s-exp->list s)))
           (s-exp->symbol (third (s-exp->list s)))
           (parse (fourth (s-exp->list s))))]
    [(s-exp-match? `{begin ANY ANY} s)
     (beginE (parse (second (s-exp->list s)))
             (parse (third (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x)
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (multE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (letE 'x (plusE (numE 1) (numE 2))
              (idE 'y)))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test (parse `{record {x 2} {y 3}})
        (recordE (list 'x 'y)
                 (list (numE 2) (numE 3))))
  (test (parse `{get {+ 1 2} a})
        (getE (plusE (numE 1) (numE 2)) 'a))
  (test (parse `{set! {+ 1 2} a 7})
        (setE (plusE (numE 1) (numE 2)) 'a (numE 7)))
  (test (parse `{begin {+ 1 2} a})
        (beginE (plusE (numE 1) (numE 2)) (idE 'a)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env]) : Value
  (type-case Exp a
    [(numE n) (numV n)]
    [(idE s) (lookup s env)]
    [(plusE l r) (num+ (interp l env) (interp r env))]
    [(multE l r) (num* (interp l env) (interp r env))]
    [(letE n rhs body)
          (interp body
                  (extend-env
                   (bind n (interp rhs env))
                   env))]
    [(lamE n body) (closV n body env)]
    [(appE fun arg) (type-case Value (interp fun env)
                      [(closV n body c-env)
                             (interp body
                                     (extend-env
                                      (bind n
                                            (interp arg env))
                                      c-env))]
                      [else (error 'interp "not a function")])]
    [(recordE ns as)
     (recV ns
           (map (lambda (a) (box (interp a env)))
                as))]
    [(getE a n)
     (type-case Value (interp a env)
       [(recV ns vs) (unbox (find n ns vs))]
       [else (error 'interp "not a record")])]
    [(setE a n v)
     (type-case Value (interp a env)
       [(recV ns vs)
        (let ([f (interp v env)])
          (begin
            (set-box! (find n ns vs) f)
            f))]
       [else (error 'interp "not a record")])]
    [(beginE l r)
     (begin
       (interp l env)
       (interp r env))]))

(module+ test
  (test (interp (parse `2) mt-env)
        (numV 2))
  (test/exn (interp (parse `x) mt-env)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x (numV 9)) mt-env))
        (numV 9))
  (test (interp (parse `{+ 2 1}) mt-env)
        (numV 3))
  (test (interp (parse `{* 2 1}) mt-env)
        (numV 2))
  (test (interp (parse `{+ {* 2 3} {+ 5 8}})
                mt-env)
        (numV 19))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env)
        (closV 'x (plusE (idE 'x) (idE 'x)) mt-env))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env)
        (numV 10))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env)
        (numV 12))
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env)
        (numV 5))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env)
        (numV 16))
  (test (interp (parse `{begin 1 2})
                mt-env)
        (numV 2))

  (test (interp (parse `{record {a {+ 1 1}}
                                {b {+ 2 2}}})
                mt-env)
        (recV (list 'a 'b) 
              (list (box (numV 2)) (box (numV 4)))))
  (test (interp (parse `{get {record {a {+ 1 1}}
                                     {b {+ 2 2}}} a})
                mt-env)
        (numV 2))
  (test (interp (parse `{get {record {a {+ 1 1}}
                                     {b {+ 2 2}}} b})
                mt-env)
        (numV 4))
  (test (interp (parse `{let {[o {record {a {+ 1 1}}
                                         {b {+ 2 2}}}]}
                          {begin
                            {set! o a 5}
                            o}})
                mt-env)
        (recV (list 'a 'b) 
              (list (box (numV 5)) (box (numV 4)))))

  (test/exn (interp (parse `{1 2}) mt-env)
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env)
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env)
            "free variable")
  (test/exn (interp (parse `{get 6 x}) mt-env)
            "not a record")
  (test/exn (interp (parse `{set! 6 x 9}) mt-env)
            "not a record"))

;; num+ and num* ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num* [l : Value] [r : Value]) : Value
  (num-op * l r))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num* (numV 2) (numV 3))
        (numV 6)))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Value
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-val b)]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x (numV 8)) mt-env))
        (numV 8))
  (test (lookup 'x (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'x (numV 8)) mt-env)))
        (numV 9))
  (test (lookup 'y (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'y (numV 8)) mt-env)))
        (numV 8)))
  
;; find ----------------------------------------

;; Takes a name and two parallel lists, returning an item from the
;; second list where the name matches the item from the first list.
(define (find [n : Symbol] [ns : (Listof Symbol)] [vs : (Listof (Boxof Value))])
  : (Boxof Value)
  (cond
   [(empty? ns) (error 'interp "no such field")]
   [else (if (symbol=? n (first ns))
             (first vs)
             (find n (rest ns) (rest vs)))]))

(module+ test
  (test (find 'a (list 'a 'b) (list (box (numV 1)) (box (numV 2))))
        (box (numV 1)))
  (test (find 'b (list 'a 'b) (list (box (numV 1)) (box (numV 2))))
        (box (numV 2)))
  (test/exn (find 'a empty empty)
            "no such field"))

(module+ test
  (test (interp (parse `{let {[swap! {lambda {r}
                                       {let {[r-x {get r x}]}
                                         {begin
                                           {set! r x {get r y}}
                                           {set! r y r-x}}}}]}
                          {let {[re {record {x 2} {y 3}}]}
                            {begin
                              {swap! re}
                              re}}})
                mt-env)
        (recV (list 'x 'y) (list (box (numV 3)) (box (numV 2))))))
______________



__Notes__

imparative update - any object that has access to that object will see the update involves state.

functional update - instead of changing object create new object with updated value.
                    Doesnt involve state.

imperative update -> mutable datatype
functional update -> persistent datatype


Variables ********************************************************

__Class Demo__

#lang plait ;;;;;;;;;;;;;;

;; Start with "variable.rkt"

;; Add a `{++ <id>}` form that increments a variable's value
;; (requiring that it has a number value) and returns the
;; incremented value

(define-type-alias Location Number)

(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (plusplusE [var : Symbol])
  (multE [l : Exp]
         [r : Exp])
  (letE [n : Symbol] 
        [rhs : Exp]
        [body : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun : Exp]
        [arg : Exp])
  (setE [var : Symbol]
        [val : Exp])
  (beginE [l : Exp]
          [r : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [location : Location]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(define-type Storage
  (cell [location : Location] 
        [val : Value]))

(define-type-alias Store (Listof Storage))
(define mt-store empty)
(define override-store cons)

(define-type Result
  (v*s [v : Value] [s : Store]))

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{++ SYMBOL} s) (plusplusE (s-exp->symbol (second (s-exp->list s))))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (letE (s-exp->symbol (first bs))
             (parse (second bs))
             (parse (third (s-exp->list s)))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{set! SYMBOL ANY} s)
     (setE (s-exp->symbol (second (s-exp->list s)))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{begin ANY ANY} s)
     (beginE (parse (second (s-exp->list s)))
             (parse (third (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x)
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (multE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (letE 'x (plusE (numE 1) (numE 2))
              (idE 'y)))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test (parse `{set! b 0})
        (setE 'b (numE 0)))
  (test (parse `{begin 1 2})
        (beginE (numE 1) (numE 2)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; with form ----------------------------------------
(define-syntax-rule
  (with [(v-id sto-id) call]
    body)
  (type-case Result call
    [(v*s v-id sto-id) body]))
                                
;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env] [sto : Store]) : Result
  (type-case Exp a
    [(numE n) (v*s (numV n) sto)]
    [(idE s) (v*s (fetch (lookup s env) sto)
                  sto)]
    [(plusE l r)
     (with [(v-l sto-l) (interp l env sto)]
       (with [(v-r sto-r) (interp r env sto-l)]
         (v*s (num+ v-l v-r) sto-r)))]
    [(multE l r)
     (with [(v-l sto-l) (interp l env sto)]
       (with [(v-r sto-r) (interp r env sto-l)]
         (v*s (num* v-l v-r) sto-r)))]
    [(letE n rhs body)
     (with [(v-rhs sto-rhs) (interp rhs env sto)]
       (let ([l (new-loc sto-rhs)])
         (interp body
                 (extend-env (bind n l)
                             env)
                 (override-store (cell l v-rhs)
                                 sto-rhs))))]
    [(lamE n body)
     (v*s (closV n body env) sto)]
    [(appE fun arg)
     (with [(v-f sto-f) (interp fun env sto)]
       (with [(v-a sto-a) (interp arg env sto-f)]
         (type-case Value v-f
           [(closV n body c-env)
            (let ([l (new-loc sto-a)])
              (interp body
                      (extend-env (bind n l)
                                  c-env)
                      (override-store (cell l v-a)
                                      sto-a)))]
           [else (error 'interp "not a function")])))]
    [(setE var val)
     (let ([l (lookup var env)])
       (with [(v-v sto-v) (interp val env sto)]
         (v*s v-v
              (override-store (cell l v-v)
                              sto-v))))]
    [(beginE l r)
     (with [(v-l sto-l) (interp l env sto)]
       (interp r env sto-l))]
    [(plusplusE s) (let ([l (lookup s env)])
                         (type-case Value (fetch l sto)
                           [(numV n) (let ([num (numV (+ n 1))])
                                       (v*s num (override-store (cell l num) sto)))]
                           [else(error 'interp "not a number")]))]))

(module+ test
  (test (interp (parse `2) mt-env mt-store)
        (v*s (numV 2) 
             mt-store))
  (test/exn (interp (parse `x) mt-env mt-store)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x 1) mt-env)
                (override-store (cell 1 (numV 9))
                                mt-store))
        (v*s (numV 9)
             (override-store (cell 1 (numV 9))
                             mt-store)))
  (test (interp (parse `{+ 2 1}) mt-env mt-store)
        (v*s (numV 3)
             mt-store))
  (test (interp (parse `{* 2 1}) mt-env mt-store)
        (v*s (numV 2)
             mt-store))
  (test (interp (parse `{+ {* 2 3} {+ 5 8}})
                mt-env
                mt-store)
        (v*s (numV 19)
             mt-store))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env
                mt-store)
        (v*s (closV 'x (plusE (idE 'x) (idE 'x)) mt-env)
             mt-store))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env
                mt-store)
        (v*s (numV 10)
             (override-store (cell 1 (numV 5))
                             mt-store)))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env
                mt-store)
        (v*s (numV 12)
             (override-store (cell 2 (numV 6))
                             (override-store (cell 1 (numV 5))
                                             mt-store))))
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env
                mt-store)
        (v*s (numV 5)
             (override-store (cell 2 (numV 6))
                             (override-store (cell 1 (numV 5))
                                             mt-store))))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env
                mt-store)
        (v*s (numV 16)
             (override-store (cell 1 (numV 8))
                             mt-store)))
  (test (interp (parse `{begin 1 2})
                mt-env
                mt-store)
        (v*s (numV 2)
             mt-store))
  (test (interp (parse `{let {[x 5]}
                          {begin
                            {set! x 6}
                            x}})
                mt-env
                mt-store)
        (v*s (numV 6)
             (override-store (cell 1 (numV 6))
                             (override-store (cell 1 (numV 5))
                                             mt-store))))

  (test (interp (parse `{let {[x 5]}
                          {begin
                            {++ x}
                            x}})
                mt-env
                mt-store)
        (v*s (numV 6) (override-store (cell 1 (numV 6))
                             (override-store (cell 1 (numV 5))
                                             mt-store))))

  (test (interp (parse `{++ x})
                (extend-env (bind 'x 1) mt-env)
                (override-store (cell 1 (numV 5))
                                mt-store))
        (v*s (numV 6) (override-store (cell 1 (numV 6))
                                      (override-store (cell 1 (numV 5))
                                                      mt-store))))

  (test/exn (interp (parse `{1 2}) mt-env mt-store)
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env mt-store)
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env
                    mt-store)
            "free variable"))

;; num+ and num* ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num* [l : Value] [r : Value]) : Value
  (num-op * l r))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num* (numV 2) (numV 3))
        (numV 6)))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Location
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-location b)]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x 8) mt-env))
        8)
  (test (lookup 'x (extend-env
                    (bind 'x 9)
                    (extend-env (bind 'x 8) mt-env)))
        9)
  (test (lookup 'y (extend-env
                    (bind 'x 9)
                    (extend-env (bind 'y 8) mt-env)))
        8))
  
;; store operations ----------------------------------------

(define (new-loc [sto : Store]) : Location
  (+ 1 (max-address sto)))

(define (max-address [sto : Store]) : Location
  (type-case (Listof Storage) sto
   [empty 0]
   [(cons c rst-sto) (max (cell-location c)
                          (max-address rst-sto))]))

(define (fetch [l : Location] [sto : Store]) : Value
  (type-case (Listof Storage) sto
   [empty (error 'interp "unallocated location")]
   [(cons c rst-sto) (if (equal? l (cell-location c))
                         (cell-val c)
                         (fetch l rst-sto))]))

(module+ test
  (test (max-address mt-store)
        0)
  (test (max-address (override-store (cell 2 (numV 9))
                                     mt-store))
        2)
  
  (test (fetch 2 (override-store (cell 2 (numV 9))
                                 mt-store))
        (numV 9))
  (test (fetch 2 (override-store (cell 2 (numV 10))
                                 (override-store (cell 2 (numV 9))
                                                 mt-store)))
        (numV 10))
  (test (fetch 3 (override-store (cell 2 (numV 10))
                                 (override-store (cell 3 (numV 9))
                                                 mt-store)))
        (numV 9))
  (test/exn (fetch 2 mt-store)
            "unallocated location"))



#lang plait ;;;;;;;;;;;;;;;;

(define-type-alias Location Number)

(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (multE [l : Exp]
         [r : Exp])
  (letE [n : Symbol] 
        [rhs : Exp]
        [body : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun : Exp]
        [arg : Exp])
  (setE [var : Symbol]
        [val : Exp])
  (beginE [l : Exp]
          [r : Exp])
  (fluidletE [n : Symbol] 
             [rhs : Exp]
             [body : Exp]))
          

(define-type Binding
  (bind [name : Symbol]
        [location : Location]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(define-type Storage
  (cell [location : Location] 
        [val : Value]))

(define-type-alias Store (Listof Storage))
(define mt-store empty)
(define override-store cons)

(define-type Result
  (v*s [v : Value] [s : Store]))

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (letE (s-exp->symbol (first bs))
             (parse (second bs))
             (parse (third (s-exp->list s)))))]
    [(s-exp-match? `{fluid-let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (fluidletE (s-exp->symbol (first bs))
                  (parse (second bs))
                  (parse (third (s-exp->list s)))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{set! SYMBOL ANY} s)
     (setE (s-exp->symbol (second (s-exp->list s)))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{begin ANY ANY} s)
     (beginE (parse (second (s-exp->list s)))
             (parse (third (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x)
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (multE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (letE 'x (plusE (numE 1) (numE 2))
              (idE 'y)))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test (parse `{set! b 0})
        (setE 'b (numE 0)))
  (test (parse `{begin 1 2})
        (beginE (numE 1) (numE 2)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; with form ----------------------------------------
(define-syntax-rule
  (with [(v-id sto-id) call]
    body)
  (type-case Result call
    [(v*s v-id sto-id) body]))
                                
;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env] [sto : Store]) : Result
  (type-case Exp a
    [(numE n) (v*s (numV n) sto)]
    [(idE s) (v*s (fetch (lookup s env) sto)
                  sto)]
    [(plusE l r)
     (with [(v-l sto-l) (interp l env sto)]
       (with [(v-r sto-r) (interp r env sto-l)]
         (v*s (num+ v-l v-r) sto-r)))]
    [(multE l r)
     (with [(v-l sto-l) (interp l env sto)]
       (with [(v-r sto-r) (interp r env sto-l)]
         (v*s (num* v-l v-r) sto-r)))]
    [(letE n rhs body)
     (with [(v-rhs sto-rhs) (interp rhs env sto)]
       (let ([l (new-loc sto-rhs)])
         (interp body
                 (extend-env (bind n l)
                             env)
                 (override-store (cell l v-rhs)
                                 sto-rhs))))]
    [(fluidletE n rhs body)
     (with [(v-rhs sto-rhs) (interp rhs env sto)]           
       (let ([l (lookup n env)])
         (let ([tmp (fetch l sto-rhs)])
           (with ([v-r sto-r] (interp body
                                      env
                                      (override-store (cell l v-rhs)
                                                      sto-rhs)))
                 (v*s v-r
                      (override-store (cell l tmp)
                                      sto-r))))))]
    [(lamE n body)
     (v*s (closV n body env) sto)]
    [(appE fun arg)
     (with [(v-f sto-f) (interp fun env sto)]
       (with [(v-a sto-a) (interp arg env sto-f)]
         (type-case Value v-f
           [(closV n body c-env)
            (let ([l (new-loc sto-a)])
              (interp body
                      (extend-env (bind n l)
                                  c-env)
                      (override-store (cell l v-a)
                                      sto-a)))]
           [else (error 'interp "not a function")])))]
    [(setE var val)
     (let ([l (lookup var env)])
       (with [(v-v sto-v) (interp val env sto)]
         (v*s v-v
              (override-store (cell l v-v)
                              sto-v))))]
    [(beginE l r)
     (with [(v-l sto-l) (interp l env sto)]
       (interp r env sto-l))]))

(module+ test
  (test (interp (parse `2) mt-env mt-store)
        (v*s (numV 2) 
             mt-store))
  (test/exn (interp (parse `x) mt-env mt-store)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x 1) mt-env)
                (override-store (cell 1 (numV 9))
                                mt-store))
        (v*s (numV 9)
             (override-store (cell 1 (numV 9))
                             mt-store)))
  (test (interp (parse `{+ 2 1}) mt-env mt-store)
        (v*s (numV 3)
             mt-store))
  (test (interp (parse `{* 2 1}) mt-env mt-store)
        (v*s (numV 2)
             mt-store))
  (test (interp (parse `{+ {* 2 3} {+ 5 8}})
                mt-env
                mt-store)
        (v*s (numV 19)
             mt-store))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env
                mt-store)
        (v*s (closV 'x (plusE (idE 'x) (idE 'x)) mt-env)
             mt-store))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env
                mt-store)
        (v*s (numV 10)
             (override-store (cell 1 (numV 5))
                             mt-store)))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env
                mt-store)
        (v*s (numV 12)
             (override-store (cell 2 (numV 6))
                             (override-store (cell 1 (numV 5))
                                             mt-store))))
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env
                mt-store)
        (v*s (numV 5)
             (override-store (cell 2 (numV 6))
                             (override-store (cell 1 (numV 5))
                                             mt-store))))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env
                mt-store)
        (v*s (numV 16)
             (override-store (cell 1 (numV 8))
                             mt-store)))
  (test (interp (parse `{begin 1 2})
                mt-env
                mt-store)
        (v*s (numV 2)
             mt-store))
  (test (interp (parse `{let {[x 5]}
                          {begin
                            {set! x 6}
                            x}})
                mt-env
                mt-store)
        (v*s (numV 6)
             (override-store (cell 1 (numV 6))
                             (override-store (cell 1 (numV 5))
                                             mt-store))))

  (test (interp (parse `{let {[x 1]}
                          {let {[f {lambda {y}
                                     {+ y x}}]}
                            {fluid-let {[x 2]}
                              {f 0}}}})
                mt-env
                mt-store)
        (v*s (numV 2)
             (list (cell 1 (numV 1))
                   (cell 3 (numV 0))
                   (cell 1 (numV 2))
                   (cell 2 (closV 'y
                                  (plusE (idE 'y) (idE 'x))
                                  (extend-env(bind 'x 1)mt-env)))
                   (cell 1 (numV 1)))))

  (test/exn (interp (parse `{1 2}) mt-env mt-store)
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env mt-store)
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env
                    mt-store)
            "free variable"))

;; num+ and num* ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num* [l : Value] [r : Value]) : Value
  (num-op * l r))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num* (numV 2) (numV 3))
        (numV 6)))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Location
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-location b)]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x 8) mt-env))
        8)
  (test (lookup 'x (extend-env
                    (bind 'x 9)
                    (extend-env (bind 'x 8) mt-env)))
        9)
  (test (lookup 'y (extend-env
                    (bind 'x 9)
                    (extend-env (bind 'y 8) mt-env)))
        8))
  
;; store operations ----------------------------------------

(define (new-loc [sto : Store]) : Location
  (+ 1 (max-address sto)))

(define (max-address [sto : Store]) : Location
  (type-case (Listof Storage) sto
   [empty 0]
   [(cons c rst-sto) (max (cell-location c)
                          (max-address rst-sto))]))

(define (fetch [l : Location] [sto : Store]) : Value
  (type-case (Listof Storage) sto
   [empty (error 'interp "unallocated location")]
   [(cons c rst-sto) (if (equal? l (cell-location c))
                         (cell-val c)
                         (fetch l rst-sto))]))

(module+ test
  (test (max-address mt-store)
        0)
  (test (max-address (override-store (cell 2 (numV 9))
                                     mt-store))
        2)
  
  (test (fetch 2 (override-store (cell 2 (numV 9))
                                 mt-store))
        (numV 9))
  (test (fetch 2 (override-store (cell 2 (numV 10))
                                 (override-store (cell 2 (numV 9))
                                                 mt-store)))
        (numV 10))
  (test (fetch 3 (override-store (cell 2 (numV 10))
                                 (override-store (cell 3 (numV 9))
                                                 mt-store)))
        (numV 9))
  (test/exn (fetch 2 mt-store)
            "unallocated location"))

______________

__Notes__

Variable and box implementation have the same effectivenss.

Call by reference - you peek into the store and and dont recuresuively call interp on it so its is a bit suspicous.


Encodings **********************************************************

__Class Demo__

#lang plait

(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun : Exp]
        [arg : Exp])
  (if0E [tst : Exp]
        [thn : Exp]
        [els : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [val : Value]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    ;; Encoding lists (in terms of pairs):
    [(s-exp-match? `empty s)
     (parse `{pair 0 0})]
    [(s-exp-match? `{empty? ANY} s)
     (let ([input-list-s (second (s-exp->list s))])
       (parse `{fst ,input-list-s}))]
    [(s-exp-match? `{cons? ANY} s)
     (let ([input-list-s (second (s-exp->list s))])
       (parse `{if0 {fst ,input-list-s} 1 0}))]
    [(s-exp-match? `{first ANY} s)
     (let ([input-list-s (second (s-exp->list s))])
       (parse `{fst {snd ,input-list-s}}))]
    [(s-exp-match? `{rest ANY} s)
     (let ([input-list-s (second (s-exp->list s))])
       (parse `{snd {snd ,input-list-s}}))]
    [(s-exp-match? `{cons ANY ANY} s)
     (let ([first-s (second (s-exp->list s))]
           [second-s (third (s-exp->list s))])
       (parse `{pair 1 {pair ,first-s ,second-s}}))]
    ;; Encoding pairs (in terms of lambdas):
    [(s-exp-match? `{pair ANY ANY} s)
     (let ([first-s (second (s-exp->list s))]
           [second-s (third (s-exp->list s))])
       (parse `{lambda {s} {if0 s ,first-s ,second-s}}))]
    [(s-exp-match? `{fst ANY} s)
     (let ([inputPair (second (s-exp->list s))])
       (parse `{,inputPair 0}))]
    [(s-exp-match? `{snd ANY} s)
     (let ([inputPair (second (s-exp->list s))])
       (parse `{,inputPair 1}))]
    ;; Encoding booleans (in terms of lambdas):
    [(s-exp-match? `false s) (parse `{lambda {x} {lambda {y} y}})]
    [(s-exp-match? `true s)  (parse `{lambda {x} {lambda {y} x}})]
    [(s-exp-match? `{if ANY ANY ANY} s)
     (let ([tst-s (second (s-exp->list s))]
           [thn-s (third (s-exp->list s))]
           [els-s (fourth (s-exp->list s))])
       (parse `{{,tst-s ,thn-s} ,els-s})
       #;
       (appE (appE (parse tst-s)
                   (parse thn-s))
             (parse els-s)))]
    ;; Original forms
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (appE (lamE (s-exp->symbol (first bs))
                   (parse (third (s-exp->list s))))
             (parse (second bs))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{if0 ANY ANY ANY} s)
     (if0E (parse (second (s-exp->list s)))
           (parse (third (s-exp->list s)))
           (parse (fourth (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x) ; note: backquote instead of normal quote
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{+ {+ 3 4} 8})
        (plusE (plusE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (appE (lamE 'x (idE 'y))
              (plusE (numE 1) (numE 2))))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{if0 1 2 3})
        (if0E (numE 1) (numE 2) (numE 3)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env]) : Value
  (type-case Exp a
    [(numE n) (numV n)]
    [(idE s) (lookup s env)]
    [(plusE l r) (num+ (interp l env) (interp r env))]
    [(lamE n body)
     (closV n body env)]
    [(appE fun arg) (type-case Value (interp fun env)
                      [(closV n body c-env)
                       (interp body
                               (extend-env
                                (bind n
                                      (interp arg env))
                                c-env))]
                      [else (error 'interp "not a function")])]
    [(if0E tst thn els)
     (interp (if (num-zero? (interp tst env))
                 thn
                 els)
             env)]))

(module+ test
  (test (interp (parse `2) mt-env)
        (numV 2))
  (test/exn (interp (parse `x) mt-env)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x (numV 9)) mt-env))
        (numV 9))
  (test (interp (parse `{+ 2 1}) mt-env)
        (numV 3))
  (test (interp (parse `{+ {+ 2 3} {+ 5 8}})
                mt-env)
        (numV 18))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env)
        (closV 'x (plusE (idE 'x) (idE 'x)) mt-env))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env)
        (numV 10))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env)
        (numV 12))
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env)
        (numV 5))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env)
        (numV 16))
  
  (test (interp (parse `{if0 0 2 3})
                mt-env)
        (numV 2))
  (test (interp (parse `{if0 1 2 3})
                mt-env)
        (numV 3))

  (test/exn (interp (parse `{1 2}) mt-env)
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env)
            "not a number")
  (test/exn (interp (parse `{if0 {lambda {x} x} 2 3})
                    mt-env)
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env)
            "free variable"))

;; num+ ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num-zero? [v : Value]) : Boolean
  (type-case Value v
    [(numV n) (zero? n)]
    [else (error 'interp "not a number")]))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num-zero? (numV 0))
        #t)
  (test (num-zero? (numV 1))
        #f))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Value
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-val b)]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x (numV 8)) mt-env))
        (numV 8))
  (test (lookup 'x (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'x (numV 8)) mt-env)))
        (numV 9))
  (test (lookup 'y (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'y (numV 8)) mt-env)))
        (numV 8)))

;; ----------------------------------------
;; Some encoding tests

(module+ test
  (test (interp (parse `{if true 1 2})
                mt-env)
        (numV 1))
  (test (interp (parse `{if false 1 2})
                mt-env)
        (numV 2))

  (test (interp (parse `{fst {pair 3 4}})
                mt-env)
        (numV 3))
  (test (interp (parse `{snd {pair 3 4}})
                mt-env)
        (numV 4))

  (test (interp (parse `{empty? empty})
                mt-env)
        (numV 0))
  (test (interp (parse `{empty? {cons 1 empty}})
                mt-env)
        (numV 1))
  (test (interp (parse `{cons? {cons 1 empty}})
                mt-env)
        (numV 0))
  (test (interp (parse `{cons? empty})
                mt-env)
        (numV 1))
  (test (interp (parse `{first {rest {cons 10 {cons 20 empty}}}})
                mt-env)
        (numV 20))
  (test (interp (parse `{empty? {rest {rest {cons 10 {cons 20 empty}}}}})
                mt-env)
        (numV 0)))
______________

__Notes__

Syntactic Sugar - makes programs easier to read but the construct can be implemented using existing constructs

Syntacitic sugar and library extensions are both forms of encoding.

We are interested in identifying constructs that are fundemetally expressive in a language and what is syntactic sugar (construct made using other constructs).

Alonzo Church
  lambda calculas
  Church numerals



Encoding Recursion **********************************************************

__Class Demo__

#lang plait #:untyped

;;1- Using (let ...) implement `len function recursively, which takes a list and returns its length
;;2- implement `sum-l function recursively, which takes a list and returns the summation of all its elements


#;(let ([len (lambda (l)
             (type-case (Listof 'x) l
               (empty 0)
               ((cons fst rst)
                (+ 1 (len rst)))))])
  (len (list 1 2 3)))

;; implement the same code using (if ...) instead of (type-case ...)
;; The following is not working because the binding in let is not known on the rhs.
#;(let ([len (lambda (l)
             (if (empty? l)
                 0
                (+ 1 (len (rest l)))))])
  (len (list 1 2 3)))

;; pass the function to itself as an arg, so that it is known in the lambda body.
#;(let ([lenX (lambda (lenX l)
             (if (empty? l)
                 0
                 (+ 1 (lenX lenX (rest l)))))])
  (lenX lenX (list 1 2 3)))

;; the original len definition is the word len, so wrap the above (let ...) in a (lambda ...) and bind it to the word len.
#;(let ([len (lambda (l)
             (let ([lenX (lambda (lenX l)
                           (if (empty? l)
                               0
                               (+ 1 (lenX lenX (rest l)))))])
               (lenX lenX l)))])
  (len (list 1 2 3)))

;; curry only lenX => encode 2 arg lambda as 1 arg lambdas
#;(let ([len
       (lambda (l)
             (let ([lenX
                    (lambda (lenX)
                           (lambda (l)
                             (if (empty? l)
                                 0
                                 (+ 1 ((lenX lenX) (rest l))))))])
               ((lenX lenX) l)))])
  (len (list 1 2 3)))

;; Simplify by removinf the first (lambda (l) ...)
#;(let ([len
       (let ([lenX
              (lambda (lenX)
                (lambda (l)
                  (if (empty? l)
                      0
                      (+ 1 ((lenX lenX) (rest l))))))])
         (lenX lenX))])
(len (list 1 2 3)))

;; almost the original len, except that instead of (len ...) we have (lenX lenX) => bind (lenX lenX) to the word len, but
;; the self-application (lenX lenX) at (let ([len (letX letX)]) ...) will be evaluated always, which makes an infinite loop.
;; Whereas, previously we had the self-application only in the else branch.
#;(let ([len
       (let ([lenX
              (lambda (lenX)
                (let ([len (lenX lenX)])
                  (lambda (l)
                    (if (empty? l)
                        0
                        (+ 1 (len (rest l)))))))])
         (lenX lenX))])
(len (list 1 2 3)))

;; To fix the infinit loop caused by binding the self-application to len => delay its evaluation by wraping it in a lambda
(let ([len
       (let ([lenX
              (lambda (lenX)
                (let ([len (lambda (n)
                             ((lenX lenX) n))])
                  (lambda (l)
                    (if (empty? l)
                        0
                        (+ 1 (len (rest l)))))))])
         (lenX lenX))])
(len (list 1 2 3)))

;`sum-l
(let ([sum-l
       (let ([sumX
              (lambda (sumX)
                (let ([sum-l (lambda (n)
                               ((sumX sumX) n))])
                  (lambda (l)
                    (if (empty? l)
                        0
                        (+ (first l) (sum-l (rest l)))))))])
         (sumX sumX))])
  (sum-l (list 1 2 3)))











(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun : Exp]
        [arg : Exp])
  (if0E [tst : Exp]
        [thn : Exp]
        [els : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [val : Value]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    ;; Encoding lists (in terms of pairs):
    [(s-exp-match? `empty s)
     (parse `{pair 0 0})]
    [(s-exp-match? `{empty? ANY} s)
     (let ([input-list-s (second (s-exp->list s))])
       (parse `{fst ,input-list-s}))]
    [(s-exp-match? `{cons? ANY} s)
     (let ([input-list-s (second (s-exp->list s))])
       (parse `{if0 {fst ,input-list-s} 1 0}))]
    [(s-exp-match? `{first ANY} s)
     (let ([input-list-s (second (s-exp->list s))])
       (parse `{fst {snd ,input-list-s}}))]
    [(s-exp-match? `{rest ANY} s)
     (let ([input-list-s (second (s-exp->list s))])
       (parse `{snd {snd ,input-list-s}}))]
    [(s-exp-match? `{cons ANY ANY} s)
     (let ([first-s (second (s-exp->list s))]
           [second-s (third (s-exp->list s))])
       (parse `{pair 1 {pair ,first-s ,second-s}}))]
    ;; Encoding pairs (in terms of lambdas):
    [(s-exp-match? `{pair ANY ANY} s)
     (let ([first-s (second (s-exp->list s))]
           [second-s (third (s-exp->list s))])
       (parse `{lambda {s} {if0 s ,first-s ,second-s}}))]
    [(s-exp-match? `{fst ANY} s)
     (let ([inputPair (second (s-exp->list s))])
       (parse `{,inputPair 0}))]
    [(s-exp-match? `{snd ANY} s)
     (let ([inputPair (second (s-exp->list s))])
       (parse `{,inputPair 1}))]
    ;; Encoding booleans (in terms of lambdas):
    [(s-exp-match? `false s) (parse `{lambda {x} {lambda {y} y}})]
    [(s-exp-match? `true s)  (parse `{lambda {x} {lambda {y} x}})]
    [(s-exp-match? `{if ANY ANY ANY} s)
     (let ([tst-s (second (s-exp->list s))]
           [thn-s (third (s-exp->list s))]
           [els-s (fourth (s-exp->list s))])
       (parse `{{,tst-s ,thn-s} ,els-s})
       #;
       (appE (appE (parse tst-s)
                   (parse thn-s))
             (parse els-s)))]
    ;; Original forms
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (appE (lamE (s-exp->symbol (first bs))
                   (parse (third (s-exp->list s))))
             (parse (second bs))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{if0 ANY ANY ANY} s)
     (if0E (parse (second (s-exp->list s)))
           (parse (third (s-exp->list s)))
           (parse (fourth (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x) ; note: backquote instead of normal quote
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{+ {+ 3 4} 8})
        (plusE (plusE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (appE (lamE 'x (idE 'y))
              (plusE (numE 1) (numE 2))))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{if0 1 2 3})
        (if0E (numE 1) (numE 2) (numE 3)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env]) : Value
  (type-case Exp a
    [(numE n) (numV n)]
    [(idE s) (lookup s env)]
    [(plusE l r) (num+ (interp l env) (interp r env))]
    [(lamE n body)
     (closV n body env)]
    [(appE fun arg) (type-case Value (interp fun env)
                      [(closV n body c-env)
                       (interp body
                               (extend-env
                                (bind n
                                      (interp arg env))
                                c-env))]
                      [else (error 'interp "not a function")])]
    [(if0E tst thn els)
     (interp (if (num-zero? (interp tst env))
                 thn
                 els)
             env)]))

(module+ test
  (test (interp (parse `2) mt-env)
        (numV 2))
  (test/exn (interp (parse `x) mt-env)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x (numV 9)) mt-env))
        (numV 9))
  (test (interp (parse `{+ 2 1}) mt-env)
        (numV 3))
  (test (interp (parse `{+ {+ 2 3} {+ 5 8}})
                mt-env)
        (numV 18))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env)
        (closV 'x (plusE (idE 'x) (idE 'x)) mt-env))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env)
        (numV 10))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env)
        (numV 12))
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env)
        (numV 5))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env)
        (numV 16))
  
  (test (interp (parse `{if0 0 2 3})
                mt-env)
        (numV 2))
  (test (interp (parse `{if0 1 2 3})
                mt-env)
        (numV 3))

  (test/exn (interp (parse `{1 2}) mt-env)
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env)
            "not a number")
  (test/exn (interp (parse `{if0 {lambda {x} x} 2 3})
                    mt-env)
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env)
            "free variable"))

;; num+ ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num-zero? [v : Value]) : Boolean
  (type-case Value v
    [(numV n) (zero? n)]
    [else (error 'interp "not a number")]))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num-zero? (numV 0))
        #t)
  (test (num-zero? (numV 1))
        #f))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Value
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-val b)]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x (numV 8)) mt-env))
        (numV 8))
  (test (lookup 'x (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'x (numV 8)) mt-env)))
        (numV 9))
  (test (lookup 'y (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'y (numV 8)) mt-env)))
        (numV 8)))

;; ----------------------------------------
;; Some encoding tests

(module+ test
  (test (interp (parse `{if true 1 2})
                mt-env)
        (numV 1))
  (test (interp (parse `{if false 1 2})
                mt-env)
        (numV 2))

  (test (interp (parse `{fst {pair 3 4}})
                mt-env)
        (numV 3))
  (test (interp (parse `{snd {pair 3 4}})
                mt-env)
        (numV 4))

  (test (interp (parse `{empty? empty})
                mt-env)
        (numV 0))
  (test (interp (parse `{empty? {cons 1 empty}})
                mt-env)
        (numV 1))
  (test (interp (parse `{cons? {cons 1 empty}})
                mt-env)
        (numV 0))
  (test (interp (parse `{cons? empty})
                mt-env)
        (numV 1))
  (test (interp (parse `{first {rest {cons 10 {cons 20 empty}}}})
                mt-env)
        (numV 20))
  (test (interp (parse `{empty? {rest {rest {cons 10 {cons 20 empty}}}}})
                mt-env)
        (numV 0)))
______________

__Notes__

Plait local keyword binds both in the body expression and in the binding expression

let only binds in the body so it does not work for recursion

letrec

mk-rec is known as a Y cominator or fixpoint operator

Values bound by let dont exits until the body of the let.

letrec lets you see all bindings in all clauses. 


Recursion **********************************************************

__Class Demo__

#lang plait

;; Start with "letrec-ubi.rkt"

;; Generalize `letrec` to have multiple binding clauses

;; Make `letrec` act like `shared` in the special case of
;; a right-hand side that refers immediately in `box` back
;; to the identifier being defined

(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env])
  (boxV [b : (Boxof Value)]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (multE [l : Exp]
         [r : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun : Exp]
        [arg : Exp])
  (if0E [tst : Exp]
        [thn : Exp]
        [els : Exp])
  (boxE [itm : Exp])
  (unboxE [b : Exp])
  (letrecE [n : (Listof Symbol)] 
           [rhs : (Listof Exp)]
           [body : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [val : (Boxof (Optionof Value))]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{box ANY} s)
     (boxE (parse (second (s-exp->list s))))]
    [(s-exp-match? `{unbox ANY} s)
     (unboxE (parse (second (s-exp->list s))))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (appE (lamE (s-exp->symbol (first bs))
                   (parse (third (s-exp->list s))))
             (parse (second bs))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{letrec {[SYMBOL ANY] ...} ANY} s)
     (let ([clauses (s-exp->list (second
                                  (s-exp->list s)))])       
       (letrecE (map (lambda (clause)
                       (s-exp->symbol (first (s-exp->list clause))))
                     clauses)
                (map (lambda (clause)
                       (parse (second (s-exp->list clause))))
                     clauses)
                (parse (third (s-exp->list s)))))]
    [(s-exp-match? `{if0 ANY ANY ANY} s)
     (if0E (parse (second (s-exp->list s)))
           (parse (third (s-exp->list s)))
           (parse (fourth (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x) ; note: backquote instead of normal quote
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (multE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (appE (lamE 'x (idE 'y))
              (plusE (numE 1) (numE 2))))
  (test (parse `{if0 1 2 3})
        (if0E (numE 1) (numE 2) (numE 3)))
  (test (parse `{letrec {[x {+ 1 2}]}
                  y})
        (letrecE (list 'x)
                 (list (plusE (numE 1) (numE 2)))
                 (idE 'y)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env]) : Value
  (type-case Exp a
    [(numE n) (numV n)]
    [(idE s) (lookup s env)]
    [(plusE l r) (num+ (interp l env) (interp r env))]
    [(multE l r) (num* (interp l env) (interp r env))]
    [(boxE e) (boxV (box (interp e env)))]
    [(unboxE b)
     (type-case Value (interp b env)
       [(boxV v) (unbox v)]
       [else (error 'interp "not a box")])]
    [(lamE n body) (closV n body env)]
    [(appE fun arg) (type-case Value (interp fun env)
                      [(closV n body c-env)
                             (let ([val (interp arg env)])
                               (interp body
                                       (extend-env
                                        (bind n (box (some val)))
                                        c-env)))]
                      [else (error 'interp "not a function")])]
    [(if0E tst thn els)
     (type-case Value (interp tst env)
       [(numV n) (if (zero? n)
                     (interp thn env)
                     (interp els env))]
       [else (error 'interp "not a number")])]
    [(letrecE ns rhss body)
     (local [(define (general-letrec)
               (let ([bs (map (lambda (n)
                                (box (none)))
                              ns)])
                 (let ([new-env (append
                                 (map2 bind
                                       ns
                                       bs)
                                 env)])
                   (begin
                     (map2 (lambda (rhs b)
                             (set-box! b (some (interp rhs new-env))))
                           rhss
                           bs)
                     (interp body new-env)))))]
       (cond
         [(= 1 (length ns))
          (type-case Exp (first rhss)
            [(boxE e)
             (type-case Exp e
               [(idE n) (if (equal? n (first ns))
                            ;; Make a box that refers to itself
                            (let ([bx (box (numV 42))])
                              (let ([b (boxV bx)])
                                (begin
                                  (set-box! bx b)
                                  b)))
                            (general-letrec))]
               [else (general-letrec)])]
            [else (general-letrec)])]
         [else (general-letrec)]))]))

(module+ test
  (test (interp (parse `{letrec {[b (box b)]}
                          {unbox b}})
                mt-env)
        #;
        (shared ([b (boxV (box b))])
          b)
        ;; #0=(boxV (box #0#))
        (let ([bx (box (numV 42))])
          (let ([b (boxV bx)])
            (begin
              (set-box! bx b)
              b))))
  (test (interp (parse `{letrec {[x 5]
                                 [y {+ x 2}]}
                          {+ x y}})
                mt-env)
        (numV 12))

  (test (interp (parse `{letrec {[x {box 5}]}
                          x})
                mt-env)
        (boxV (box (numV 5))))
  (test (interp (parse `{let {[y 8]}
                          {letrec {[x {box y}]}
                            x}})
                mt-env)
        (boxV (box (numV 8))))
  
  (test (interp (parse `(letrec ([is-odd (lambda (n)
                                           (if0 n
                                                0
                                               (is-even (+ n -1))))]
                                 [is-even (lambda (n)
                                            (if0 n
                                                 1
                                                (is-odd (+ n -1))))])
                          (is-odd 5)))
                mt-env)
        (numV 1))

  (test (interp (parse `{unbox {box 0}})
                mt-env)
        (numV 0))
  (test/exn (interp (parse `{unbox 0})
                    mt-env)
            "not a box")
                       
  (test (interp (parse `2) mt-env)
        (numV 2))
  (test/exn (interp (parse `x) mt-env)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x (box (some (numV 9)))) mt-env))
        (numV 9))
  (test (interp (parse `{+ 2 1}) mt-env)
        (numV 3))
  (test (interp (parse `{* 2 1}) mt-env)
        (numV 2))
  (test (interp (parse `{+ {* 2 3} {+ 5 8}})
                mt-env)
        (numV 19))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env)
        (closV 'x (plusE (idE 'x) (idE 'x)) mt-env))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env)
        (numV 10))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env)
        (numV 12))
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env)
        (numV 5))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env)
        (numV 16))
  (test (interp (parse `{if0 1 2 3})
                mt-env)
        (numV 3))
  (test (interp (parse `{if0 0 2 3})
                mt-env)
        (numV 2))

  (test (interp (parse `{letrec {[x 5]}
                          {+ x x}})
                mt-env)
        (numV 10))

  (test (interp (parse `{letrec {[fac
                                  {lambda {x}
                                    {if0 x
                                         1
                                         {* x {fac {+ x -1}}}}}]}
                          {fac 5}})
                mt-env)
        (numV 120))

  (test/exn (interp (parse `{1 2}) mt-env)
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env)
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env)
            "free variable")
  (test/exn (interp (parse `{if0 {lambda {x} x} 1 2})
                    mt-env)
            "not a number")

  (test/exn (interp (parse `{letrec {[x x]} x})
                    mt-env)
            "use before initialization"))

;; num+ and num* ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num* [l : Value] [r : Value]) : Value
  (num-op * l r))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num* (numV 2) (numV 3))
        (numV 6)))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Value
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (type-case (Optionof Value) (unbox (bind-val b))
                          [(none) (error 'lookup "use before initialization")]
                          [(some v) v])]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x (box (some (numV 8)))) mt-env))
        (numV 8))
  (test (lookup 'x (extend-env
                    (bind 'x (box (some (numV 9))))
                    (extend-env (bind 'x (box (some (numV 8)))) mt-env)))
        (numV 9))
  (test (lookup 'y (extend-env
                    (bind 'x (box (some (numV 9))))
                    (extend-env (bind 'y (box (some (numV 8)))) mt-env)))
        (numV 8))
  (test/exn (lookup 'x (extend-env (bind 'x (box (none))) mt-env))
            "use before initialization"))
______________

__Notes__



Lazy Evaluation **********************************************************


__Class Demo__

#lang plait

;; Start with "more-lazy.rkt", and add boxes:
;;   {box <expr>}
;;   {unbox <expr>}

;; Part of the challenge here was writing a test
;; case that returns a box containing a forced value.

(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env])
  (boxV [b : Thunk]))

(define-type Thunk
  (delay [body : Exp]
         [env : Env]
         [done : (Boxof (Optionof Value))]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (multE [l : Exp]
         [r : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun : Exp]
        [arg : Exp])
  (boxE [b : Exp])
  (unboxE [ub : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [val : Thunk]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{box ANY} s)
     (boxE (parse (second (s-exp->list s))))]
    [(s-exp-match? `{unbox ANY} s)
     (unboxE (parse (second (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (appE (lamE (s-exp->symbol (first bs))
                   (parse (third (s-exp->list s))))
             (parse (second bs))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x) ; note: backquote instead of normal quote
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (multE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (appE (lamE 'x (idE 'y))
              (plusE (numE 1) (numE 2))))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env]) : Value
  (type-case Exp a
    [(numE n) (numV n)]
    [(idE s) (force (lookup s env))]
    [(plusE l r) (num+ (interp l env)
                       (interp r env))]
    [(multE l r) (num* (interp l env)
                       (interp r env))]
    [(lamE n body) (closV n body env)]
    [(boxE b) (boxV (delay b env (box (none))))]
    [(unboxE ub)
     (type-case Value (interp ub env)
       [(boxV t) (force t)]
       [else (error 'interp "not a box")])]
    [(appE fun arg) (type-case Value (interp fun env)
                      [(closV n body c-env)
                             (interp body
                                     (extend-env
                                      (bind n (delay arg env (box (none))))
                                      c-env))]
                      [else (error 'interp "not a function")])]))

(module+ test
  (test (interp (parse `{let {[b {box 5}]}
                          {unbox b}})
                mt-env)
        (numV 5))
  (test/exn (interp (parse `{let {[b {box [1 2]}]}
                          {unbox b}})
                mt-env)
        "not a function")
  (test (interp (parse `{let {[b {box [1 2]}]}
                          b})
                mt-env)
        (boxV (delay (appE (numE 1) (numE 2))
                     mt-env
                     (box (none)))))
  ;; Doesn't work:
  #;
  (test (interp (parse `{let {[b {box {+ 1 2}}]}
                          {let {[dummy {unbox b}]}
                            b}})
                mt-env)
        (boxV (delay (plusE (numE 1) (numE 2))
                     mt-env
                     (box (some (numV 3))))))
  (test (interp (parse `{let {[b {box {lambda {x} x}}]}
                          {{unbox b}
                           b}})
                mt-env)
        (boxV (delay (parse `{lambda {x} x})
                     mt-env
                     (box (some (closV 'x (idE 'x) mt-env))))))
  (test (interp (parse `2) mt-env)
        (numV 2))
  (test/exn (interp (parse `x) mt-env)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x (delay (numE 9) mt-env (box (none)))) mt-env))
        (numV 9))
  (test (interp (parse `{+ 2 1}) mt-env)
        (numV 3))
  (test (interp (parse `{* 2 1}) mt-env)
        (numV 2))
  (test (interp (parse `{+ {* 2 3} {+ 5 8}})
                mt-env)
        (numV 19))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env)
        (closV 'x (plusE (idE 'x) (idE 'x)) mt-env))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env)
        (numV 10))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env)
        (numV 12))
  (test (interp (parse `{let {[x 5]}
                         {let {[y 6]}
                          x}})
                mt-env)
        (numV 5))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env)
        (numV 16))

  (test (interp (parse `{{lambda {x} 5} {1 2}})
                 mt-env)
        (numV 5))

  (test/exn (interp (parse `{1 2}) mt-env)
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env)
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env)
            "free variable")

  #;
  (time (interp (parse '{let {[x2 {lambda {n} {+ n n}}]}
                          {let {[x4 {lambda {n} {x2 {x2 n}}}]}
                            {let {[x16 {lambda {n} {x4 {x4 n}}}]}
                              {let {[x256 {lambda {n} {x16 {x16 n}}}]}
                                {let {[x65536 {lambda {n} {x256 {x256 n}}}]}
                                  {x65536 1}}}}}})
                mt-env)))

;; force ----------------------------------------

(define (force [t : Thunk]) : Value
  (type-case Thunk t
    [(delay b e d) (type-case (Optionof Value) (unbox d)
                     [(none )
                           (let ([v (interp b e)])
                             (begin
                               (set-box! d (some v))
                               v))]
                     [(some v) v])]))

(module+ test
  (test (force (delay (numE 8) mt-env (box (none))))
        (numV 8))
  (test (let ([v (delay (numE 8) mt-env (box (none)))])
          (begin
            (force v)
            (force v)))
        (numV 8))
  (test (force (delay (numE 8) mt-env (box (some (numV 9)))))
        (numV 9))
  (test (force (delay (idE 'x)
                      (extend-env (bind 'x (delay (numE 9) mt-env (box (none))))
                                  mt-env)
                      (box (none))))
        (numV 9)))

;; num+ and num* ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num* [l : Value] [r : Value]) : Value
  (num-op * l r))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num* (numV 2) (numV 3))
        (numV 6)))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Thunk
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-val b)]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x (delay (numE 8) mt-env (box (none)))) mt-env))
        (delay (numE 8) mt-env (box (none))))
  (test (lookup 'x (extend-env
                    (bind 'x (delay (numE 9) mt-env (box (none))))
                    (extend-env (bind 'x (delay (numE 8) mt-env (box (none)))) mt-env)))
        (delay (numE 9) mt-env (box (none))))
  (test (lookup 'y (extend-env
                    (bind 'x (delay (numE 9) mt-env (box (none))))
                    (extend-env (bind 'y (delay (numE 8) mt-env (box (none)))) mt-env)))
        (delay (numE 8) mt-env (box (none)))))
______________

__Notes__

Eager evaluation: languages like Plait, Java, C
	- an expression is evaluated when it is encountered.
	- function parameters are evaluated before the body of the function.

Lazy evaluation: languages like Hascal, Clean
	-an expression is evaluated only if its result is needed.

ex.
(define (f x)
	(+ x 1))

(f (+ 3 4)) ; eager -> (f 7) -> (+ 7 1) -> 8
			; lazy  -> (+ (+ 3 4) 1) -> (+ 7 1) -> 8
 

call-by-value -> means eager / ex. plait, java, c, python
call-by-name  -> means lazy no chaching of results / ex. not practical. theoretical
call-by-need  -> means lazy, with caching of results / ex. Haskell, Clean

normal order -> lazy evaluation
applicative order -> eager evaluation


function postion needs to be evealuated.
argument postion can be lazy.






Continuations **********************************************************

__Class Demo__

#lang plait ;;;;;;;;;;;;;

;; Start with lambda-k.rkt
;;
;; Add `pair`, `fst`, and `snd`

(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env])
  (pairV [a : Value]
         [b : Value]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (multE [l : Exp]
         [r : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun : Exp]
        [arg : Exp])
  (pairE [a : Exp]
         [b : Exp])
  (fstE [exp : Exp])
  (sndE [exp : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [val : Value]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(define-type Cont
  (doneK)
  (plusSecondK [r : Exp]
               [e : Env]
               [k : Cont])
  (doPlusK [v : Value]
           [k : Cont])
  (multSecondK [r : Exp]
               [e : Env]
               [k : Cont])
  (doMultK [v : Value]
           [k : Cont])
  (appArgK [a : Exp]
           [env : Env]
           [k : Cont])
  (doAppK [f : Value]
          [k : Cont])
  (pairSecondK [exp : Exp]
               [env : Env]
               [k : Cont])
  (doPairK [a : Value]
           [k : Cont])
  (doFstK [k : Cont ])
  (doSndK [k : Cont ]))

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{pair ANY ANY} s)
     (pairE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{fst ANY} s)
     (fstE (parse (second (s-exp->list s))))]
    [(s-exp-match? `{snd ANY} s)
     (sndE (parse (second (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (appE (lamE (s-exp->symbol (first bs))
                   (parse (third (s-exp->list s))))
             (parse (second bs))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x)
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (multE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (appE (lamE 'x (idE 'y))
              (plusE (numE 1) (numE 2))))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; interp & continue ----------------------------------------
(define (interp [a : Exp] [env : Env] [k : Cont]) : Value
  (type-case Exp a
    [(numE n) (continue k (numV n))]
    [(idE s) (continue k (lookup s env))]
    [(plusE l r) (interp l env
                         (plusSecondK r env k))]
    [(multE l r) (interp l env
                         (multSecondK r env k))]
    [(lamE n body)
     (continue k (closV n body env))]
    [(pairE a b) (interp a env (pairSecondK b env k))]
    [(fstE e) (interp e env ( doFstK k))]
    [(sndE e) (interp e env ( doSndK k))]
                      
    [(appE fun arg) (interp fun env
                            (appArgK arg env k))]))

(define (continue [k : Cont] [v : Value]) : Value
  (type-case Cont k
    [(doneK) v]
    [(plusSecondK r env next-k)
     (interp r env
             (doPlusK v next-k))]
    [(doPlusK v-l next-k)
     (continue next-k (num+ v-l v))]
    [(multSecondK r env next-k)
     (interp r env
             (doMultK v next-k))]
    [(doMultK v-l next-k)
     (continue next-k (num* v-l v))]
    [(appArgK a env next-k)
     (interp a env
             (doAppK v next-k))]
    [(pairSecondK exp env next-k) (interp exp env (doPairK v next-k))]
    [(doPairK a next-k) (continue next-k (pairV a v))]
    [(doFstK next-k) (type-case Value v
                       [(pairV f s) (continue next-k f)]
                       [else (error 'interp "not a pair")])]
    [(doSndK next-k) (type-case Value v
                       [(pairV f s) (continue next-k s)]
                       [else (error 'interp "not a pair")])]
    [(doAppK v-f next-k)
     (type-case Value v-f
       [(closV n body c-env)
        (interp body
                (extend-env
                 (bind n v)
                 c-env)
                next-k)]
       [else (error 'interp "not a function")])]))

(module+ test
  (test (interp (parse `{pair 5 6}) mt-env (doneK))
        (pairV (numV 5) (numV 6)))
  (test (interp (parse `{fst {pair 5 6}}) mt-env (doneK))
        (numV 5))
  (test (interp (parse `{snd {pair 5 6}}) mt-env (doneK))
        (numV 6))

  (test (interp (parse `{+ 1 {snd {pair 5 6}}}) mt-env (doneK))
        (numV 7))
  
  (test (interp (parse `2) mt-env (doneK))
        (numV 2))
  (test/exn (interp (parse `x) mt-env (doneK))
            "free variable")
  (test (interp (parse `x)
                (extend-env (bind 'x (numV 9)) mt-env)
                (doneK))
        (numV 9))
  (test (interp (parse `{+ 2 1}) mt-env (doneK))
        (numV 3))
  (test (interp (parse `{* 2 1}) mt-env (doneK))
        (numV 2))
  (test (interp (parse `{+ {* 2 3} {+ 5 8}})
                mt-env
                (doneK))
        (numV 19))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env
                (doneK))
        (closV 'x (plusE (idE 'x) (idE 'x)) mt-env))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env
                (doneK))
        (numV 10))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env
                (doneK))
        (numV 12))
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env
                (doneK))
        (numV 5))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env
                (doneK))
        (numV 16))

  (test/exn (interp (parse `{1 2}) mt-env (doneK))
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env (doneK))
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env
                    (doneK))
            "free variable")
  ;; Eager:
  (test/exn (interp (parse `{{lambda {x} 0} {1 2}}) mt-env (doneK))
            "not a function")

  (test (continue (doneK) (numV 5))
        (numV 5))
  (test (continue (plusSecondK (numE 6) mt-env (doneK)) (numV 5))
        (numV 11))
  (test (continue (doPlusK (numV 7) (doneK)) (numV 5))
        (numV 12))
  (test (continue (multSecondK (numE 6) mt-env (doneK)) (numV 5))
        (numV 30))
  (test (continue (doMultK (numV 7) (doneK)) (numV 5))
        (numV 35))
  (test (continue (appArgK (numE 5) mt-env (doneK)) (closV 'x (idE 'x) mt-env))
        (numV 5))
  (test (continue (doAppK (closV 'x (idE 'x) mt-env) (doneK)) (numV 8))
        (numV 8)))

;; num+ and num* ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num* [l : Value] [r : Value]) : Value
  (num-op * l r))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num* (numV 2) (numV 3))
        (numV 6)))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Value
  (type-case (Listof Binding) env
    [empty (error 'lookup "free variable")]
    [(cons b rst-env) (cond
                        [(symbol=? n (bind-name b))
                         (bind-val b)]
                        [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x (numV 8)) mt-env))
        (numV 8))
  (test (lookup 'x (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'x (numV 8)) mt-env)))
        (numV 9))
  (test (lookup 'y (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'y (numV 8)) mt-env)))
        (numV 8)))



#lang plait ;;;;;;;;;;;;

(define-type Value
  (numV [n : Number])
  (closV [arg : Symbol]
         [body : Exp]
         [env : Env]))

(define-type Exp
  (numE [n : Number])
  (idE [s : Symbol])
  (plusE [l : Exp] 
         [r : Exp])
  (multE [l : Exp]
         [r : Exp])
  (letE [n : Symbol] 
        [rhs : Exp]
        [body : Exp])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun : Exp]
        [arg : Exp]))

(define-type Binding
  (bind [name : Symbol]
        [val : Value]))

(define-type-alias Env (Listof Binding))

(define mt-env empty)
(define extend-env cons)

(module+ test
  (print-only-errors #t))

;; parse ----------------------------------------
(define (parse [s : S-Exp]) : Exp
  (cond
    [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
    [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
    [(s-exp-match? `{+ ANY ANY} s)
     (plusE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{* ANY ANY} s)
     (multE (parse (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
    [(s-exp-match? `{let {[SYMBOL ANY]} ANY} s)
     (let ([bs (s-exp->list (first
                             (s-exp->list (second
                                           (s-exp->list s)))))])
       (letE (s-exp->symbol (first bs))
             (parse (second bs))
             (parse (third (s-exp->list s)))))]
    [(s-exp-match? `{lambda {SYMBOL} ANY} s)
     (lamE (s-exp->symbol (first (s-exp->list 
                                  (second (s-exp->list s)))))
           (parse (third (s-exp->list s))))]
    [(s-exp-match? `{ANY ANY} s)
     (appE (parse (first (s-exp->list s)))
           (parse (second (s-exp->list s))))]
    [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `2)
        (numE 2))
  (test (parse `x)
        (idE 'x))
  (test (parse `{+ 2 1})
        (plusE (numE 2) (numE 1)))
  (test (parse `{* 3 4})
        (multE (numE 3) (numE 4)))
  (test (parse `{+ {* 3 4} 8})
        (plusE (multE (numE 3) (numE 4))
               (numE 8)))
  (test (parse `{let {[x {+ 1 2}]}
                  y})
        (letE 'x (plusE (numE 1) (numE 2))
              (idE 'y)))
  (test (parse `{lambda {x} 9})
        (lamE 'x (numE 9)))
  (test (parse `{double 9})
        (appE (idE 'double) (numE 9)))
  (test/exn (parse `{{+ 1 2}})
            "invalid input"))

;; continuations --------------------
(define-type-alias Cont (Value -> Value))
(define (done-k v) v)

;; interp ----------------------------------------
(define (interp [a : Exp] [env : Env] [k : Cont]) : Value
  (type-case Exp a
    [(numE n) (k (numV n))]
    [(idE s) (k (lookup s env))]
    [(plusE l r) (interp l env
                         (lambda (v-l)
                           (interp r env
                                   (lambda (v-r)
                                     (k (num+ v-l v-r))))))]
    [(multE l r) (interp l env
                         (lambda (v-l)
                           (interp r env
                                   (lambda (v-r)
                                     (k (num* v-l v-r))))))]
    [(letE n rhs body) (interp rhs env
                               (lambda (v-rhs)
                                 (interp body
                                         (extend-env
                                          (bind n v-rhs)
                                          env)
                                         k)))]
    [(lamE n body) (k (closV n body env))]
    [(appE fun arg) (interp fun env
                            (lambda (v-fun)
                              (type-case Value v-fun
                                [(closV n body c-env)
                                 (interp arg env
                                         (lambda (arg-v)
                                           (interp body
                                                   (extend-env
                                                    (bind n
                                                          arg-v)
                                                    c-env)
                                                   k)))]
                                [else (error 'interp "not a function")])))]))

(module+ test
  (test (interp (parse `2) mt-env done-k)
        (numV 2))
  (test/exn (interp (parse `x) mt-env done-k)
            "free variable")
  (test (interp (parse `x) 
                (extend-env (bind 'x (numV 9)) mt-env)
                done-k)
        (numV 9))
  (test (interp (parse `{+ 2 1}) mt-env done-k)
        (numV 3))
  (test (interp (parse `{* 2 1}) mt-env done-k)
        (numV 2))
  (test (interp (parse `{+ {* 2 3} {+ 5 8}})
                mt-env
                done-k)
        (numV 19))
  (test (interp (parse `{lambda {x} {+ x x}})
                mt-env
                done-k)
        (closV 'x (plusE (idE 'x) (idE 'x)) mt-env))
  (test (interp (parse `{let {[x 5]}
                          {+ x x}})
                mt-env
                done-k)
        (numV 10))
  (test (interp (parse `{let {[x 5]}
                          {let {[x {+ 1 x}]}
                            {+ x x}}})
                mt-env
                done-k)
        (numV 12))
  (test (interp (parse `{let {[x 5]}
                          {let {[y 6]}
                            x}})
                mt-env
                done-k)
        (numV 5))
  (test (interp (parse `{{lambda {x} {+ x x}} 8})
                mt-env
                done-k)
        (numV 16))

  (test/exn (interp (parse `{1 2}) mt-env done-k)
            "not a function")
  (test/exn (interp (parse `{+ 1 {lambda {x} x}}) mt-env done-k)
            "not a number")
  (test/exn (interp (parse `{let {[bad {lambda {x} {+ x y}}]}
                              {let {[y 5]}
                                {bad 2}}})
                    mt-env
                    done-k)
            "free variable")

  #;
  (time (interp (parse '{let {[x2 {lambda {n} {+ n n}}]}
                          {let {[x4 {lambda {n} {x2 {x2 n}}}]}
                            {let {[x16 {lambda {n} {x4 {x4 n}}}]}
                              {let {[x256 {lambda {n} {x16 {x16 n}}}]}
                                {let {[x65536 {lambda {n} {x256 {x256 n}}}]}
                                  {x65536 1}}}}}})
                mt-env
                done-k)))

;; num+ and num* ----------------------------------------
(define (num-op [op : (Number Number -> Number)] [l : Value] [r : Value]) : Value
  (cond
   [(and (numV? l) (numV? r))
    (numV (op (numV-n l) (numV-n r)))]
   [else
    (error 'interp "not a number")]))
(define (num+ [l : Value] [r : Value]) : Value
  (num-op + l r))
(define (num* [l : Value] [r : Value]) : Value
  (num-op * l r))

(module+ test
  (test (num+ (numV 1) (numV 2))
        (numV 3))
  (test (num* (numV 2) (numV 3))
        (numV 6)))

;; lookup ----------------------------------------
(define (lookup [n : Symbol] [env : Env]) : Value
  (type-case (Listof Binding) env
   [empty (error 'lookup "free variable")]
   [(cons b rst-env) (cond
                       [(symbol=? n (bind-name b))
                        (bind-val b)]
                       [else (lookup n rst-env)])]))

(module+ test
  (test/exn (lookup 'x mt-env)
            "free variable")
  (test (lookup 'x (extend-env (bind 'x (numV 8)) mt-env))
        (numV 8))
  (test (lookup 'x (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'x (numV 8)) mt-env)))
        (numV 9))
  (test (lookup 'y (extend-env
                    (bind 'x (numV 9))
                    (extend-env (bind 'y (numV 8)) mt-env)))
        (numV 8)))

  

______________

__Notes__

How to continue wih the computation once we get a value. ( a to do list )
A stack is one way to implement continuations.

Infinite loops
	Tail Calls - recursive function will run forever because there is no work to do after the function returns.
	ex.
		(define (forever x)
			(forever (not x)))
	ex2.
		(define (forever x)
			(if x
				(forever #t)
				(forever #f)))

	Non-Tail Calls - will run out of memory because it is not in tail postion and because there is work to do after it returns.
	ex.
		(define (run-out-of-memory x)
			(not (run-out-of-memory x)))
	ex2.
		(define (run-out-of-memory x)
			(if (run-out-of-memory x)
				#t
				#f))

In lambda-k.rkt: 
	- interp call continue only as a tail call.
	- continue calls interp only as a tail call.
	- lookup calls lookup only as a tail call.
	- So Plait continuation is always small and wont run out of memory becuare of how we arranged the recursive calls.

Dont ever just return a value.
Errors discard any continuations.
Dont ever look at the result of interp or continue

Continuation passing style (CPS): continuations using functions

Passing work along to be done later. 
In java going through a tree recursively might blow up the stack so you might need a continuation or in c or something using queues or something else.

interp
	pairE l r (pairV (interp l env) (intperp r env)) ; no continuations

	(continure k (pairV (interp l env) (intperp r env))) ; this would pass all tests but Matt is not happy with it. THis is becuase we just take advantage of Plait.

interp and continue must be in tail postion



Errors Exceptions and call/cc *************************************************


__Class Demo__

TRACE 1 ;;;;;;;;;;;;;;;;;
;; For each step:
;;   - interp or continue?
;;   - after, did we lose anything? the same result?

(interp (parse '{{lambda {x} {+ x 2}}
                 8})
        mt-env
        (doneK))

;; appE
(interp {lambda {x} {+ x 2}}
        mt-env
        (appArgK `8 mt-env (doneK)))

(continue
 (appArgK `8 mt-env (doneK))
 v1 = (closV 'x (plusE (idE 'x) (numE 2)) mt-env))

(interp `8
        mt-env
        (doAppK v1 (doneK)))

(continue
 (doAppK v1 (doneK))
 (numV 8))

(interp (plusE (idE 'x) (numE 2))
        e1 = (extend-env (bind 'x (numV 8)) mt-env)
        (doneK))

(interp 'x
        (e1)
       k2 = (plusSecondK (numE 2) (e1) (doneK)))

(continue
 (k2)
 (numV 8))

(interp (numE 2)
        (e1)
        k3 = (doPlusK (numV 8) (doneK)))

(continue (k3) (numV 2))

(continue (doneK)
          (numV 10))

TRACE 2 ;;;;;;;;;;;
(interp (parse '{+ x 5})
        e1 = (extend-env (bind 'x (numV 8)) mt-env)
        k1 = (doMultK (numV 7) (doneK)))

(interp `x
        e1
        k2 = (plusSecondK `5 e1 k1))

(continue k2
          (numV 8))

(interp `5
        e1
        k3 = (doPlusK (numV 8) k1))

(continue k3
          (numV 5))

(continue k1
          (numV 13))

(continue (doneK)
          (numV 91))
          
TRACE 3 ;;;;;;;;;;
(interp (parse `{let/cc k
                  {+ 1 {k 8}}})
        mt-env
        (doneK))

(interp `{+ 1 {k 8}}
        e1 = (extend-env (bind 'k (contV (doneK))) mt-env)
        (doneK))

(interp `1
        e1
        k1 = (plusSecondK `{k 8} e1 (doneK)))

(continue k1
          (numV 1))

(interp `{k 8}
        e1
        k2 = (doPlusK (numV 1) (doneK)))

(interp `k
        e1
        k3 = (appArgK `8 e1 k2))

(continue k3
          (contV (doneK)))

(interp `8
        e1
        k4 = (doAppK (contV (doneK)) k2))

(continue k4
          (numV 8))

(continue (doneK)
          (numV 8))


TRACE 4 ;;;;;;;;;;;
(interp (parse '{{let/cc k k}
                 {lambda {f} 2}})
        mt-env
        (doneK))

(interp `{let/cc k k}
        mt-env
        k1 = (appArgK `{lambda {f} 2} mt-env (doneK)))

(interp `k
        (extend-env (bind 'k (contV k1)) mt-env)
        k1)

(continue (contV k1)
          k1)

(interp `{lambda {f} 2}
        mt-env
        (doAppK (contV k1) (doneK)))

(continue (doAppK (contV k1) (doneK))
          (closV 'f `2 mt-env))

(continue k1
          (closV 'f `2 mt-env))

(interp `{lambda {f} 2}
        mt-env
        (doAppK (closV 'f `2 mt-env) (doneK)))

....

______________


__Notes__

erase all previous calls to interp someone who just walked into the room should still know the final right answer. 

always use env saved in closure and extend that one. 

for each step
	- interp or continue
	- after, did we lose anything? the same result?

if we immedialty get a value then we can continue.
if we have an expression and an environment then all we can do is interp.

Expressions should always have an environment along with it.

continuation of a java stack is similar to a let/cc.

set jump and long jump in C.

Web servers taling to client cant wait for the client to send something over in the middle of a computation so a continusation is stored as what to do when you do get that information and then it can continue that continuation.

on top threads and exception.

go to this place in code with this stack


Compilation *************************************************

__Class Demo__

#lang plait

; Start with "4.rkt".
;; Add an `abs` form that takes a number
;;  and returns its absolute value.

;; Convert `interp`- and `continue`-time structures
;; to explicit allocation via `malloc`, where a tag
;; on each allocated record indicates the variant.

(define-type Exp
  (numE [n : Number])
  (plusE [lhs : Exp]
         [rhs : Exp])
  (multE [lhs : Exp]
         [rhs : Exp])
  (idE [name : Symbol])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun-expr : Exp]
        [arg-expr : Exp])
  (if0E [tst : Exp]
        [thn : Exp]
        [els : Exp])
  (absE [rhs : Exp]))

#|
    (define-type ExpD
  8   [numD (n : number)]
  9   [plusD (lhs : ExpD)
             (rhs : ExpD)]
  10  [multD (lhs : ExpD)
             (rhs : ExpD)]
  11  [atD (pos : number)]
  12  [lamD (body : ExpD)]
  13  [appD (fun-expr : ExpD)
            (arg-expr : ExpD)]
  14  [if0D (tst : ExpD)
            (thn : ExpD)
            (els : ExpD)])
  18  [absD (rhs : ExpD)]
|#

#|
    (define-type Value
  15  [numV (n : number)]
  16  [closV (body : ExprD)
             (env : Env)])

|#

(define mt-env empty)
(define extend-env cons)

(define-type BindingC
  (bindC [name : Symbol]))

(define-type-alias EnvC (Listof BindingC))

#|
    (define-type Cont
  0   [doneK]
  1   [plusSecondK (r : ExprD)
                   (env : Env)
                   (k : Cont)]
  2   [doPlusK (v1 : Value)
               (k : Cont)]
  3   [multSecondK (r : ExprD)
                   (env : Env)
                   (k : Cont)]
  4   [doMultK (v1 : Value)
               (k : Cont)]
  5   [appArgK (arg-expr : ExprD)
               (env : Env)
               (k : Cont)]
  6   [doAppK (fun-val : Value)
              (k : Cont)]
  7   [doIf0K (then-expr : ExprD)
              (else-expr : ExprD)
              (env : Env)
              (k : Cont)])
  19  [doAbsK (k : Cont)]
|#

#|
  17 cons for env
|#

(module+ test
  (print-only-errors #t))

;; ----------------------------------------
;; Allocation

(define memory (make-vector 1500 0))
(define ptr-reg 0)

(define (incptr n)
  (begin
    (set! ptr-reg (+ ptr-reg n))
    (- ptr-reg n)))

(define (malloc1 tag a)
  (begin
    (vector-set! memory ptr-reg tag) ; memory[ptr-reg] = tag
    (vector-set! memory (+ ptr-reg 1) a)
    (incptr 2)))

(define (malloc2 tag a b)
  (begin
    (vector-set! memory ptr-reg tag)
    (vector-set! memory (+ ptr-reg 1) a)
    (vector-set! memory (+ ptr-reg 2) b)
    (incptr 3)))

(define (malloc3 tag a b c)
  (begin
    (vector-set! memory ptr-reg tag)
    (vector-set! memory (+ ptr-reg 1) a)
    (vector-set! memory (+ ptr-reg 2) b)
    (vector-set! memory (+ ptr-reg 3) c)
    (incptr 4)))

(define (malloc4 tag a b c d)
  (begin
    (vector-set! memory ptr-reg tag)
    (vector-set! memory (+ ptr-reg 1) a)
    (vector-set! memory (+ ptr-reg 2) b)
    (vector-set! memory (+ ptr-reg 3) c)
    (vector-set! memory (+ ptr-reg 4) d)
    (incptr 5)))

(define (ref n d)
  (vector-ref memory (+ n d)))

;; ----------------------------------------

(define (parse [s : S-Exp]) : Exp
  (cond
   [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
   [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
   [(s-exp-match? `{+ ANY ANY} s)
    (plusE (parse (second (s-exp->list s)))
           (parse (third (s-exp->list s))))]
   [(s-exp-match? `{* ANY ANY} s)
    (multE (parse (second (s-exp->list s)))
           (parse (third (s-exp->list s))))]
   [(s-exp-match? `{abs ANY} s)
    (absE (parse (second (s-exp->list s))))]
   [(s-exp-match? `{lambda {SYMBOL} ANY} s)
    (lamE (s-exp->symbol (first (s-exp->list 
                                 (second (s-exp->list s)))))
          (parse (third (s-exp->list s))))]
   [(s-exp-match? `{ANY ANY} s)
    (appE (parse (first (s-exp->list s)))
          (parse (second (s-exp->list s))))]
   [(s-exp-match? `{if0 ANY ANY ANY} s)
    (if0E (parse (second (s-exp->list s)))
          (parse (third (s-exp->list s)))
          (parse (fourth (s-exp->list s))))]
   [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `3) (numE 3))
  (test (parse `x) (idE 'x))
  (test (parse `{+ 1 2}) (plusE (numE 1) (numE 2)))
  (test (parse `{* 1 2}) (multE (numE 1) (numE 2)))
  (test (parse `{lambda {x} x}) (lamE 'x (idE 'x)))
  (test (parse `{1 2}) (appE (numE 1) (numE 2)))
  (test (parse `{if0 0 1 2}) (if0E (numE 0) (numE 1) (numE 2)))
  (test/exn (parse `{}) "invalid input"))

;; ----------------------------------------

(define (compile a-fae env)
  (type-case Exp a-fae
    [(numE n) (malloc1 8 n)]
    [(plusE l r) (malloc2 9 (compile l env) (compile r env))]
    [(multE l r) (malloc2 10 (compile l env) (compile r env))]
    [(absE r) (malloc1 18 (compile r env))]
    [(idE name) (malloc1 11 (locate name env))]
    [(lamE n body-expr) 
     (malloc1 12 (compile body-expr (extend-env
                                     (bindC n)
                                     env)))]
    [(appE fun-expr arg-expr)
     (malloc2 13 
              (compile fun-expr env)
              (compile arg-expr env))]
    [(if0E test-expr then-expr else-expr)
     (malloc3 14
              (compile test-expr env)
              (compile then-expr env)
              (compile else-expr env))]))

(define (locate name env)
  (cond
   [(empty? env) (error 'locate "free variable")]
   [else (if (symbol=? name (bindC-name (first env)))
             0
             (+ 1 (locate name (rest env))))]))

;; ----------------------------------------

(define expr-reg 0)
(define env-reg 0)

;; interp : ExprC Env Cont -> Value
(define (interp)
  (case (ref expr-reg 0)
    [(8) ; num
     (begin
       (set! v-reg (malloc1 15 (ref expr-reg 1)))
       (continue))]
    [(9) ; plus
     (begin
       (set! k-reg (malloc3 1
                            (ref expr-reg 2)
                            env-reg 
                            k-reg))
       (set! expr-reg (ref expr-reg 1))
       (interp))]
    [(10) ; mult
     (begin
       (set! k-reg (malloc3 3
                            (ref expr-reg 2)
                            env-reg k-reg))
       (set! expr-reg (ref expr-reg 1))
       (interp))]
    [(18) ; abs
     (begin
       (set! k-reg (malloc1 19
                            k-reg))
       (set! expr-reg (ref expr-reg 1))
       (interp))]
    [(11) ; id
     (begin
       (set! env2-reg env-reg)
       (set! v-reg (ref expr-reg 1))
       (env-ref))]
    [(12) ; lam
     (begin
       (set! v-reg (malloc2 16 (ref expr-reg 1) env-reg))
       (continue))]
    [(13) ; app
     (begin
       (set! k-reg (malloc3 5
                            (ref expr-reg 2)
                            env-reg k-reg))
       (set! expr-reg (ref expr-reg 1))
       (interp))]
    [(14) ; if0
     (begin
       (set! k-reg (malloc4 7
                            (ref expr-reg 2)
                            (ref expr-reg 3)
                            env-reg k-reg))
       (set! expr-reg (ref expr-reg 1))
       (interp))]))

(define k-reg 0)
(define v-reg 0)

;; continue : Cont Value -> void
(define (continue)
  (case (ref k-reg 0)
    [(0) ; mtk
     v-reg]
    [(1) ; plusSecondK
     (begin
       (set! expr-reg (ref k-reg 1))
       (set! env-reg (ref k-reg 2))
       (set! k-reg (malloc2 2 v-reg (ref k-reg 3)))
       (interp))]
    [(2) ; doPlusK
     (begin
       (set! v-reg (num+ (ref k-reg 1) v-reg))
       (set! k-reg (ref k-reg 2))
       (continue))]
    [(3) ; multSecondK
     (begin
       (set! expr-reg (ref k-reg 1))
       (set! env-reg (ref k-reg 2))
       (set! k-reg (malloc2 4 v-reg (ref k-reg 3)))
       (interp))]
    [(4) ; doMultK
     (begin
       (set! v-reg (num* (ref k-reg 1) v-reg))
       (set! k-reg (ref k-reg 2))
       (continue))]
    [(19) ; doAbsK
     (begin
       (set! v-reg (malloc1 15 (absolute (ref v-reg 1))))
       (set! k-reg (ref k-reg 1))
       (continue))]
    [(5) ; appArgK
     (begin
       (set! expr-reg (ref k-reg 1))
       (set! env-reg (ref k-reg 2))
       (set! k-reg (malloc2 6 v-reg (ref k-reg 3)))
       (interp))]
    [(6) ; doAppK
     (begin
       (set! expr-reg (ref (ref k-reg 1) 1))
       (set! env-reg (malloc2 17
                              v-reg
                              (ref (ref k-reg 1) 2)))
       (set! k-reg (ref k-reg 2))
       (interp))]
    [(7) ; doIfK
     (begin
       (if (numzero? v-reg)
           (set! expr-reg (ref k-reg 1))
           (set! expr-reg (ref k-reg 2)))
       (set! env-reg (ref k-reg 3))
       (set! k-reg (ref k-reg 4))
       (interp))]))

;; num-op : (number number -> number) -> (Value Value -> Value)
(define (num-op op)
  (lambda (x y)
    (malloc1 15 (op (ref x 1) (ref y 1)))))

(define num+ (num-op +))
(define num* (num-op *))

(define (absolute [n : Number]) : Number
  (if (< n 0)
      (* -1 n)
      n))

(define (numzero? x)
  (zero? (ref x 1)))

(define env2-reg 0)

(define (env-ref)
  (if (zero? v-reg)
      (begin
        (set! v-reg (ref env2-reg 1))
        (continue))
      (begin
        (set! env2-reg (ref env2-reg 2))
        (set! v-reg (- v-reg 1))
        (env-ref))))

;; ----------------------------------------

(define (init-k) (malloc1 0 0))
(define (interpx a env k)
  (begin
    (set! expr-reg a)
    (set! env-reg env)
    (set! k-reg k)
    (interp)))
(define (numV x) (malloc1 15 x))
(define empty-env (malloc1 0 0))

(define (ntest v n)
  (test (ref v 1) n))

(module+ test
  (ntest (interpx (compile (parse `{abs -5}) mt-env)
                  empty-env
                  (init-k))
         5)
  (ntest (interpx (compile (parse `10) mt-env)
                  empty-env
                  (init-k))
         10)
  (ntest (interpx (compile (parse `{+ 10 7}) mt-env)
                  empty-env
                  (init-k))
         17)
  (ntest (interpx (compile (parse `{* 10 7}) mt-env)
                  empty-env
                  (init-k))
         70)
  (ntest (interpx (compile
                   (parse `{{lambda {x} {+ x 12}}
                            {+ 1 17}})
                   mt-env)
                  empty-env
                  (init-k))
         30)
  (ntest (interpx (compile (parse `x)
                           (extend-env (bindC 'x) mt-env))
                  (malloc2 17 (numV 10) empty-env)
                  (init-k))
         10)
  (ntest (interpx (compile (parse `{{lambda {x} {+ x 12}}
                                    {+ 1 17}})
                           mt-env)
                  empty-env
                  (init-k))
         30)
  (ntest (interpx (compile (parse `{{lambda {x}
                                      {{lambda {f}
                                         {+ {f 1}
                                            {{lambda {x}
                                               {f 2}}
                                             3}}}
                                       {lambda {y} {+ x y}}}}
                                    0})
                           mt-env)
                  empty-env
                  (init-k))
         3)
  (ntest (interpx (compile (parse `{if0 0 1 2})
                           mt-env)
                  empty-env
                  (init-k))
         1)
  (ntest (interpx (compile (parse `{if0 1 1 2})
                           mt-env)
                  empty-env
                  (init-k))
         2)
  (ntest (interpx (compile
                   (parse 
                    `{{lambda {mkrec}
                        {{lambda {fib}
                           ;; Call fib on 4:
                           {fib 4}}
                         ;; Create recursive fib:
                         {mkrec
                          {lambda {fib}
                            ;; Fib:
                            {lambda {n}
                              {if0 n
                                   1
                                   {if0 {+ n -1}
                                        1
                                        {+ {fib {+ n -1}}
                                           {fib {+ n -2}}}}}}}}}}
                      ;; mkrec:
                      {lambda {body-proc}
                        {{lambda {fX}
                           {fX fX}}
                         {lambda {fX}
                           {body-proc {lambda {x} {{fX fX} x}}}}}}})
                   mt-env)
                  empty-env
                  (init-k))
         5)

  (test/exn (compile (parse `x) mt-env)
            "free variable"))

(trace absolute)
______________

__Notes__






Garbage Collection *************************************************

__Class Demo__

#lang plait

; Start with "5.rkt".
;; Add an `abs` form that takes a number
;;  and returns its absolute value.

;; Garbage collection for run-time memory

(define-type Exp
  (numE [n : Number])
  (plusE [lhs : Exp]
         [rhs : Exp])
  (multE [lhs : Exp]
         [rhs : Exp])
  (idE [name : Symbol])
  (lamE [n : Symbol]
        [body : Exp])
  (appE [fun-expr : Exp]
        [arg-expr : Exp])
  (if0E [tst : Exp]
        [thn : Exp]
        [els : Exp])
  (absE [rhs : Exp]))

#|
    (define-type ExpD
  8   [numD (n : number)]
  9   [plusD (lhs : ExpD)
             (rhs : ExpD)]
  10  [multD (lhs : ExpD)
             (rhs : ExpD)]
  11  [atD (pos : number)]
  12  [lamD (body : ExpD)]
  13  [appD (fun-expr : ExpD)
            (arg-expr : ExpD)]
  14  [if0D (tst : ExpD)
            (thn : ExpD)
            (els : ExpD)]
  18  [absD (rhs : ExpD)])
|#

#|
    (define-type Value
  15  [numV (n : number)]
  16  [closV (body : ExprD)
             (env : Env)])

|#

(define mt-env empty)
(define extend-env cons)

(define-type BindingC
  (bindC [name : Symbol]))

(define-type-alias EnvC (Listof BindingC))

#|
    (define-type Cont
  0   [doneK]
  1   [plusSecondK (r : ExprD)
                   (env : Env)
                   (k : Cont)]
  2   [doPlusK (v1 : Value)
               (k : Cont)]
  3   [multSecondK (r : ExprD)
                   (env : Env)
                   (k : Cont)]
  4   [doMultK (v1 : Value)
               (k : Cont)]
  5   [appArgK (arg-expr : ExprD)
               (env : Env)
               (k : Cont)]
  6   [doAppK (fun-val : Value)
              (k : Cont)]
  7   [doIf0K (then-expr : ExprD)
              (else-expr : ExprD)
              (env : Env)
              (k : Cont)]
  19  [doAbsK (k : Cont)])
|#

#|
  17 cons for env
  99 moved
|#

(module+ test
  (print-only-errors #t))

;; ----------------------------------------
;; Allocator for code, which is never freed;
;; use `code-ref` instead of `ref` to refer to code

(define code-memory (make-vector 2048 0))
(define code-ptr 0)

(define (code-incptr n)
  (begin
    (set! code-ptr (+ code-ptr n))
    (- code-ptr n)))

(define (code-malloc1 tag a)
  (begin
    (vector-set! code-memory code-ptr tag)
    (vector-set! code-memory (+ code-ptr 1) a)
    (code-incptr 2)))

(define (code-malloc2 tag a b)
  (begin
    (vector-set! code-memory code-ptr tag)
    (vector-set! code-memory (+ code-ptr 1) a)
    (vector-set! code-memory (+ code-ptr 2) b)
    (code-incptr 3)))

(define (code-malloc3 tag a b c)
  (begin
    (vector-set! code-memory code-ptr tag)
    (vector-set! code-memory (+ code-ptr 1) a)
    (vector-set! code-memory (+ code-ptr 2) b)
    (vector-set! code-memory (+ code-ptr 3) c)
    (code-incptr 4)))

(define (code-ref n d)
  (vector-ref code-memory (+ n d)))

;; ----------------------------------------

(define (parse [s : S-Exp]) : Exp
  (cond
   [(s-exp-match? `NUMBER s) (numE (s-exp->number s))]
   [(s-exp-match? `SYMBOL s) (idE (s-exp->symbol s))]
   [(s-exp-match? `{+ ANY ANY} s)
    (plusE (parse (second (s-exp->list s)))
          (parse (third (s-exp->list s))))]
   [(s-exp-match? `{* ANY ANY} s)
    (multE (parse (second (s-exp->list s)))
          (parse (third (s-exp->list s))))]
   [(s-exp-match? `{abs ANY} s)
    (absE (parse (second (s-exp->list s))))]
   [(s-exp-match? `{lambda {SYMBOL} ANY} s)
    (lamE (s-exp->symbol (first (s-exp->list 
                                 (second (s-exp->list s)))))
          (parse (third (s-exp->list s))))]
   [(s-exp-match? `{ANY ANY} s)
    (appE (parse (first (s-exp->list s)))
          (parse (second (s-exp->list s))))]
   [(s-exp-match? `{if0 ANY ANY ANY} s)
    (if0E (parse (second (s-exp->list s)))
          (parse (third (s-exp->list s)))
          (parse (fourth (s-exp->list s))))]
   [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `3) (numE 3))
  (test (parse `x) (idE 'x))
  (test (parse `{+ 1 2}) (plusE (numE 1) (numE 2)))
  (test (parse `{* 1 2}) (multE (numE 1) (numE 2)))
  (test (parse `{lambda {x} x}) (lamE 'x (idE 'x)))
  (test (parse `{1 2}) (appE (numE 1) (numE 2)))
  (test (parse `{if0 0 1 2}) (if0E (numE 0) (numE 1) (numE 2)))
  (test/exn (parse `{}) "invalid input"))

;; ----------------------------------------

(define (compile a-fae env)
  (type-case Exp a-fae
    [(numE n) (code-malloc1 8 n)]
    [(plusE l r) (code-malloc2 9 (compile l env) (compile r env))]
    [(multE l r) (code-malloc2 10 (compile l env) (compile r env))]
    [(absE r) (code-malloc1 18 (compile r env))]
    [(idE name) (code-malloc1 11 (locate name env))]
    [(lamE n body-expr) 
     (code-malloc1 12 (compile body-expr (extend-env
                                          (bindC n)
                                          env)))]
    [(appE fun-expr arg-expr)
     (code-malloc2 13 
                   (compile fun-expr env)
                   (compile arg-expr env))]
    [(if0E test-expr then-expr else-expr)
     (code-malloc3 14
                   (compile test-expr env)
                   (compile then-expr env)
                   (compile else-expr env))]))

(define (locate name env)
  (cond
   [(empty? env) (error 'locate "free variable")]
   [else (if (symbol=? name (bindC-name (first env)))
             0
             (+ 1 (locate name (rest env))))]))

;; ----------------------------------------
;; Memory allocator with a 2-space collector
;;  for run-time allocation

(define MEMORY-SIZE 128)

(define space1 (make-vector MEMORY-SIZE 0))
(define space2 (make-vector MEMORY-SIZE 0))

(define memory space1)
(define ptr-reg 0)

(define empty-memory (make-vector 0 0))
(define from-memory empty-memory)

(define result-reg 0)

(define (incptr n)
  ;; Increment the allocation pointer, and
  ;;  if there's not enough room for the next
  ;;  allocation, then collect garbage
  (begin
    (set! ptr-reg (+ ptr-reg n))
    (if (>= (+ ptr-reg 5) MEMORY-SIZE)
        (begin
          (set! result-reg (- ptr-reg n))
          (if (eq? from-memory empty-memory)
              (gc)
              ;; Ran out of space while GCing
              ;;  => GCing didn't reclaim anything,
              ;;     so we're really out of space
              (error 'malloc "out of memory")))
        (- ptr-reg n))))

(define (malloc1 tag a)
  (begin
    (vector-set! memory ptr-reg tag)
    (vector-set! memory (+ ptr-reg 1) a)
    (incptr 2)))

(define (malloc2 tag a b)
  (begin
    (vector-set! memory ptr-reg tag)
    (vector-set! memory (+ ptr-reg 1) a)
    (vector-set! memory (+ ptr-reg 2) b)
    (incptr 3)))

(define (malloc3 tag a b c)
  (begin
    (vector-set! memory ptr-reg tag)
    (vector-set! memory (+ ptr-reg 1) a)
    (vector-set! memory (+ ptr-reg 2) b)
    (vector-set! memory (+ ptr-reg 3) c)
    (incptr 4)))

(define (malloc4 tag a b c d)
  (begin
    (vector-set! memory ptr-reg tag)
    (vector-set! memory (+ ptr-reg 1) a)
    (vector-set! memory (+ ptr-reg 2) b)
    (vector-set! memory (+ ptr-reg 3) c)
    (vector-set! memory (+ ptr-reg 4) d)
    (incptr 5)))

(define (ref n d)
  (vector-ref memory (+ n d)))


;; Pointer in to space; objects before the
;;  pointer are "black", and object after are "gray"
(define updated-ptr-reg 0)

(define (gc)
  (begin
    (display "GCing\n")
    ;; Swap to and from space:
    (set! from-memory memory)
    (if (eq? memory space1)
        (set! memory space2)
        (set! memory space1))
    (set! ptr-reg 0)
    ;; Update registers to start:
    (set! v-reg (move v-reg))
    (set! env-reg (move env-reg))
    (set! k-reg (move k-reg))
    (set! result-reg (move result-reg))
    (set! updated-ptr-reg 0)
    ;; Loop until there are no gray objects:
    (update)))

(define (update)
  (if (= updated-ptr-reg ptr-reg)
      ;; No more gray objects:
      (begin
        (set! from-memory empty-memory)
        result-reg)
      ;; updated-ptr points to first gray object:
      (case (ref updated-ptr-reg 0)
        [(0 15)
         ;; Record has just an integer
         (done 1)]
        [(1 3 5)
         (begin
           ;; Record has two run-time pointers
           ;;  in slots 2 and 3 (and an integer in 1)
           (move! 2)
           (move! 3)
           (done 3))]
        [(2 4 6 17)
         (begin
           ;; Etc.
           (move! 1)
           (move! 2)
           (done 2))]
        [(16)
         (begin
           (move! 2)
           (done 2))]
        [(19)
         (begin
           (move! 1)
           (done 1))]
        [(7)
         (begin
           (move! 3)
           (move! 4)
           (done 4))])))

(define (done n)
  (begin
    (set! updated-ptr-reg (+ updated-ptr-reg (+ n 1)))
    
    (update)))


;; move! : number -> void
;;  Updates pointer at updated-ptr+n, moving the
;;  target as necessary:
(define (move! n)
  (vector-set! memory (+ updated-ptr-reg n)
               (move (vector-ref memory (+ updated-ptr-reg n)))))

;; move : number -> number
;;  If n refers to a white record, copy it to to-space and
;;   insert a forwarding pointer, so now it's gray
;; If n refers to a gray/black record, return the forwarding
;;   pointer.
(define (move n)
  (if (= 99 (vector-ref from-memory n))
      ;; Gray/black:
      (vector-ref from-memory (+ n 1))
      ;; White:
      (begin
        (case (vector-ref from-memory n)
          [(0 15 19)
           ;; size 1
           (begin
             (malloc1 (vector-ref from-memory n)
                      (vector-ref from-memory (+ n 1)))
             (vector-set! from-memory (+ n 1) (- ptr-reg 2)))]
          [(2 4 6 16 17)
           ;; size 2
           (begin
             (malloc2 (vector-ref from-memory n)
                      (vector-ref from-memory (+ n 1))
                      (vector-ref from-memory (+ n 2)))
             (vector-set! from-memory (+ n 1) (- ptr-reg 3)))]
          [(1 3 5)
           ;; size 3
           (begin
             (malloc3 (vector-ref from-memory n)
                      (vector-ref from-memory (+ n 1))
                      (vector-ref from-memory (+ n 2))
                      (vector-ref from-memory (+ n 3)))
             (vector-set! from-memory (+ n 1) (- ptr-reg 4)))]
          [(7)
           ;; size 4
           (begin
             (malloc4 (vector-ref from-memory n)
                      (vector-ref from-memory (+ n 1))
                      (vector-ref from-memory (+ n 2))
                      (vector-ref from-memory (+ n 3))
                      (vector-ref from-memory (+ n 4)))
             (vector-set! from-memory (+ n 1) (- ptr-reg 5)))])
        ;; Change to gray:
        (vector-set! from-memory n 99)
        ;; Return forwarding porter (that we just installed):
        (vector-ref from-memory (+ n 1)))))

;; ----------------------------------------

(define expr-reg 0) ; ExprC
(define env-reg 0)  ; Env

;; interp : ExprC Env Cont -> Value
(define (interp)
  (case (code-ref expr-reg 0)
    [(8) ; num
     (begin
       (set! v-reg (malloc1 15 (code-ref expr-reg 1)))
       (continue))]
    [(9) ; plus
     (begin
       (set! k-reg (malloc3 1
                            (code-ref expr-reg 2)
                            env-reg 
                            k-reg))
       (set! expr-reg (code-ref expr-reg 1))
       (interp))]
    [(10) ; mult
     (begin
       (set! k-reg (malloc3 3
                            (code-ref expr-reg 2)
                            env-reg k-reg))
       (set! expr-reg (code-ref expr-reg 1))
       (interp))]
    [(18) ; abs
     (begin
       (set! k-reg (malloc1 19
                            k-reg))
       (set! expr-reg (code-ref expr-reg 1))
       (interp))]
    [(11) ; id
     (begin
       (set! env2-reg env-reg)
       (set! v-reg (code-ref expr-reg 1))
       (env-ref))]
    [(12) ; lam
     (begin
       (set! v-reg (malloc2 16 (code-ref expr-reg 1) env-reg))
       (continue))]
    [(13) ; app
     (begin
       (set! k-reg (malloc3 5
                            (code-ref expr-reg 2)
                            env-reg k-reg))
       (set! expr-reg (code-ref expr-reg 1))
       (interp))]
    [(14) ; if0
     (begin
       (set! k-reg (malloc4 7
                            (code-ref expr-reg 2)
                            (code-ref expr-reg 3)
                            env-reg k-reg))
       (set! expr-reg (code-ref expr-reg 1))
       (interp))]))

(define k-reg 0) ; Cont
(define v-reg 0) ; Value

;; continue : Cont Value -> Value
(define (continue)
  (case (ref k-reg 0)
    [(0) ; mtk
     v-reg]
    [(1) ; plusSecondK
     (begin
       (set! expr-reg (ref k-reg 1))
       (set! env-reg (ref k-reg 2))
       (set! k-reg (malloc2 2 v-reg (ref k-reg 3)))
       (interp))]
    [(2) ; doPlusK
     (begin
       (set! v-reg (num+ (ref k-reg 1) v-reg))
       (set! k-reg (ref k-reg 2))
       (continue))]
    [(3) ; multSecondK
     (begin
       (set! expr-reg (ref k-reg 1))
       (set! env-reg (ref k-reg 2))
       (set! k-reg (malloc2 4 v-reg (ref k-reg 3)))
       (interp))]
    [(4) ; doMultK
     (begin
       (set! v-reg (num* (ref k-reg 1) v-reg))
       (set! k-reg (ref k-reg 2))
       (continue))]
    [(19) ; doAbsK
     (case (ref v-reg 0)
       [(15)         
        (begin          
          (set! v-reg (malloc1 15 (absolute (ref v-reg 1))))
          (set! k-reg (ref k-reg 1))
          (continue))]
       [else
        (begin
          (set! k-reg (ref k-reg 1))
          (set! v-reg (malloc1 15 0))
          (continue))])]
    [(5) ; appArgK
     (begin
       (set! expr-reg (ref k-reg 1))
       (set! env-reg (ref k-reg 2))
       (set! k-reg (malloc2 6 v-reg (ref k-reg 3)))
       (interp))]
    [(6) ; doAppK
     (begin
       (set! expr-reg (ref (ref k-reg 1) 1))
       (set! env-reg (malloc2 17
                              v-reg
                              (ref (ref k-reg 1) 2)))
       (set! k-reg (ref k-reg 2))
       (interp))]
    [(7) ; doIfK
     (begin
       (if (numzero? v-reg)
           (set! expr-reg (ref k-reg 1))
           (set! expr-reg (ref k-reg 2)))
       (set! env-reg (ref k-reg 3))
       (set! k-reg (ref k-reg 4))
       (interp))]))

;; num-op : (number number -> number) -> (Value Value -> Value)
(define (num-op op)
  (lambda (x y)
    (malloc1 15 (op (ref x 1) (ref y 1)))))

(define num+ (num-op +))
(define num* (num-op *))

(define (absolute [n : Number]) : Number
  (if (< n 0)
      (* -1 n)
      n))

;; numzero? : ExprC-Value -> boolean
(define (numzero? x)
  (zero? (ref x 1)))

(define env2-reg 0)

(define (env-ref)
  (if (zero? v-reg)
      (begin
        (set! v-reg (ref env2-reg 1))
        (continue))
      (begin
        (set! env2-reg (ref env2-reg 2))
        (set! v-reg (- v-reg 1))
        (env-ref))))

;; ----------------------------------------

(define (init-k) (malloc1 0 0))
(define (interpx a env k)
  (begin
    (set! expr-reg a)
    (set! env-reg env)
    (set! k-reg k)
    (interp)))
(define (numV x) (malloc1 15 x))
(define empty-env (malloc1 0 0))

(define (ntest v n)
  (test (ref v 1) n))

(define (reset!)
  (begin
    (set! code-ptr 0)
    (set! ptr-reg 0)
    (set! v-reg 0)
    (set! expr-reg 0)
    (set! k-reg 0)
    (set! env-reg 0)
    (set! result-reg 0)
    (set! from-memory empty-memory)
    (void)))

(module+ test
  (ntest (interpx (compile (parse `{abs -5}) mt-env)
                  empty-env
                  (init-k))
         5)
  (ntest (interpx (compile (parse `10) mt-env)
                  empty-env
                  (init-k))
         10)
  (reset!)
  (ntest (interpx (compile (parse `{+ 10 7}) mt-env)
                  empty-env
                  (init-k))
         17)
  (reset!)
  (ntest (interpx (compile (parse `{* 10 7}) mt-env)
                  empty-env
                  (init-k))
         70)
  (reset!)
  (ntest (interpx (compile
                   (parse `{{lambda {x} {+ x 12}}
                            {+ 1 17}})
                   mt-env)
                  empty-env
                  (init-k))
         30)
  (reset!)
  (ntest (interpx (compile (parse `x)
                           (extend-env (bindC 'x) mt-env))
                  (malloc2 17 (numV 10) empty-env)
                  (init-k))
         10)
  (reset!)
  (ntest (interpx (compile (parse `{{lambda {x} {+ x 12}}
                                    {+ 1 17}})
                           mt-env)
                  empty-env
                  (init-k))
         30)
  (reset!)
  (ntest (interpx (compile (parse `{{lambda {x}
                                      {{lambda {f}
                                         {+ {f 1}
                                            {{lambda {x}
                                               {f 2}}
                                             3}}}
                                       {lambda {y} {+ x y}}}}
                                    0})
                           mt-env)
                  empty-env
                  (init-k))
         3)
  (reset!)
  (ntest (interpx (compile (parse `{if0 0 1 2})
                           mt-env)
                  empty-env
                  (init-k))
         1)
  (reset!)
  (ntest (interpx (compile (parse `{if0 1 1 2})
                           mt-env)
                  empty-env
                  (init-k))
         2)
  (reset!)
  (ntest (interpx (compile
                   (parse 
                    `{{lambda {mkrec}
                        {{lambda {fib}
                           ;; Call fib on 4:
                           {fib 4}}
                         ;; Create recursive fib:
                         {mkrec
                          {lambda {fib}
                            ;; Fib:
                            {lambda {n}
                              {if0 n
                                   1
                                   {if0 {+ n -1}
                                        1
                                        {+ {fib {+ n -1}}
                                           {fib {+ n -2}}}}}}}}}}
                      ;; mkrec:
                      {lambda {body-proc}
                        {{lambda {fX}
                           {fX fX}}
                         {lambda {fX}
                           {body-proc {lambda {x} {{fX fX} x}}}}}}})
                   mt-env)
                  empty-env
                  (init-k))
         5)
  (reset!)
  (ntest (interpx (compile
                   (parse 
                    `{abs {{lambda {mkrec}
                        {{lambda {fib}
                           ;; Call fib on 4:
                           {fib 4}}
                         ;; Create recursive fib:
                         {mkrec
                          {lambda {fib}
                            ;; Fib:
                            {lambda {n}
                              {if0 n
                                   1
                                   {if0 {+ n -1}
                                        1
                                        {+ {fib {+ n -1}}
                                           {fib {+ n -2}}}}}}}}}}
                      ;; mkrec:
                      {lambda {body-proc}
                        {{lambda {fX}
                           {fX fX}}
                         {lambda {fX}
                           {body-proc {lambda {x} {{fX fX} x}}}}}}}})
                   mt-env)
                  empty-env
                  (init-k))
         5)
  (reset!)
  (test/exn (interpx (compile
                      (parse
                       `{{lambda {x} {{x x} x}}
                         {lambda {x} {{x x} x}}})
                      mt-env)
                     empty-env
                     (init-k))
            "out of memory")

  (test/exn (compile (parse `x) mt-env)
            "free variable"))
______________

__Notes__

you can predict where the variable will be in the environment. 

compile has to convert to the lower level world.

GC - an object referenced by a register is live
   - an object referenced by a live object is also live




Objects *************************************************************

__Class Demo__

#lang plait

;; Start with "object.rkt"

;; Make `{get <expr> m}` call the method `m` on the object
;; produced by <expr> if that object doesn't have an `m` field.
;; Provide 0 as the argument to the method.

(define-type Exp
  (numE [n : Number])
  (plusE [lhs : Exp]
         [rhs : Exp])
  (multE [lhs : Exp]
         [rhs : Exp])
  (argE)
  (thisE)
  (objectE [fields : (Listof (Symbol * Exp))]
           [methods : (Listof (Symbol * Exp))])
  (getE [obj-expr : Exp]
        [field-name : Symbol])
  (sendE [obj-expr : Exp]
         [method-name : Symbol]
         [arg-expr : Exp]))

(define-type Value
  (numV [n : Number])
  (objV [fields : (Listof (Symbol * Value))]
        [methods : (Listof (Symbol * Exp))]))

(module+ test
  (print-only-errors #t))

;; ----------------------------------------

(define (find [l : (Listof (Symbol * 'a))] [name : Symbol]) : 'a
  (type-case (Listof (Symbol * 'a)) l
    [empty
     (error 'find (string-append "not found: " (symbol->string name)))]
    [(cons p rst-l)
     (if (symbol=? (fst p) name)
         (snd p)
         (find rst-l name))]))

(module+ test
  (test (find (list (values 'a 1)) 'a)
        1)
  (test (find (list (values 'a 1) (values 'b 2)) 'b)
        2)
  (test/exn (find empty 'a)
            "not found: a")
  (test/exn (find (list (values 'a 1)) 'x)
            "not found: x"))

;; ----------------------------------------

(define interp : (Exp Value Value -> Value)
  (lambda (a this-val arg-val)
    (type-case Exp a
      [(numE n) (numV n)]
      [(plusE l r) (num+ (interp l this-val arg-val) 
                         (interp r this-val arg-val))]
      [(multE l r) (num* (interp l this-val arg-val) 
                         (interp r this-val arg-val))]
      [(thisE) this-val]
      [(argE) arg-val]
      [(objectE fields methods)
       (objV (map (lambda (f)
                    (let ([name (fst f)]
                          [exp (snd f)])
                      (values name (interp exp this-val arg-val))))
                  fields)
             methods)]
      [(getE obj-expr field-name)
       (let ([thisObj (interp obj-expr this-val arg-val)])
         (type-case Value thisObj
           [(objV fields methods)
            (try (find fields field-name)
                 (lambda () (interp (find methods field-name)
                                    thisObj
                                    (numV 0))))]
           [else (error 'interp "not an object")]))]
      [(sendE obj-expr method-name arg-expr)
       (local [(define obj (interp obj-expr this-val arg-val))
               (define next-arg-val (interp arg-expr this-val arg-val))]
         (type-case Value obj
           [(objV fields methods)
            (let ([body-expr (find methods method-name)])
              (interp body-expr
                      obj
                      next-arg-val))]
           [else (error 'interp "not an object")]))])))

(define (num-op [op : (Number Number -> Number)]
                [op-name : Symbol] 
                [x : Value]
                [y : Value]) : Value
  (cond
    [(and (numV? x) (numV? y))
     (numV (op (numV-n x) (numV-n y)))]
    [else (error 'interp "not a number")]))

(define (num+ x y) (num-op + '+ x y))
(define (num* x y) (num-op * '* x y))

;; ----------------------------------------
;; Examples

(module+ test
  (define posn27
    (objectE
     (list (values 'x (numE 2))
           (values 'y (numE 7)))
     (list (values 'mdist
                   (plusE (getE (thisE) 'x) (getE (thisE) 'y)))
           (values 'addX
                   (plusE (getE (thisE) 'x) (argE)))
           (values 'multY (multE (argE) (getE (thisE) 'y))))))

  (define posn531
    (objectE
     (list (values 'x (numE 5))
           (values 'y (numE 3))
           (values 'z (numE 1)))
     (list (values 'mdist (plusE (getE (thisE) 'z)
                                 (plusE (getE (thisE) 'x) (getE (thisE) 'y))))))))

;; ----------------------------------------

(module+ test
  (test (interp (numE 10) 
                (objV empty empty) (numV 0))
        (numV 10))
  (test (interp (plusE (numE 10) (numE 17))
                (objV empty empty) (numV 0))
        (numV 27))
  (test (interp (multE (numE 10) (numE 7))
                (objV empty empty) (numV 0))
        (numV 70))
  (test (interp (objectE (list (values 'a (numE 1))
                               (values 'b (numE 2)))
                         (list (values 'm (numE 0))))
                (objV empty empty) (numV 0))
        (objV (list (values 'a (numV 1))
                    (values 'b (numV 2)))
              (list (values 'm (numE 0)))))
  
  (test (interp (sendE posn27 'mdist (numE 0))
                (objV empty empty) (numV 0))
        (numV 9))
  
  (test (interp (sendE posn27 'addX (numE 10))
                (objV empty empty) (numV 0))
        (numV 12))
  
  (test/exn (interp (plusE (numE 1) (objectE empty empty))
                    (objV empty empty) (numV 0))
            "not a number")
  (test/exn (interp (getE (numE 1) 'x)
                    (objV empty empty) (numV 0))
            "not an object")
  (test/exn (interp (sendE (numE 1) 'mdist (numE 0))
                    (objV empty empty) (numV 0))
            "not an object")
  (test (interp (getE (objectE (list) ;;no field m
                               (list (values 'm ;;we want to get the method instead
                                             (plusE (numE 1) (numE 2)))))
                      'm)
                (objV empty empty)
                (numV 0))
        (numV 3)))
                
                
______________

__Notes__

Functioal programming
	- oftem means using functions as values
	- often means dataype-oriented programming

Datatype oriented 
	- add a new operation => new function
	- add a new variant   => change functions

Object oriented
	- add a new operation => change objects
	- add a new variant   => new objects


need to allocate for continuations

continuation takes a value and a contiuation

done returns size of what has been moved.


Objects *************************************************************

__Class Demo__

#lang plait

;; Start with "object.rkt"

;; Make `{get <expr> m}` call the method `m` on the object
;; produced by <expr> if that object doesn't have an `m` field.
;; Provide 0 as the argument to the method.

(define-type Exp
  (numE [n : Number])
  (plusE [lhs : Exp]
         [rhs : Exp])
  (multE [lhs : Exp]
         [rhs : Exp])
  (argE)
  (thisE)
  (objectE [fields : (Listof (Symbol * Exp))]
           [methods : (Listof (Symbol * Exp))])
  (getE [obj-expr : Exp]
        [field-name : Symbol])
  (sendE [obj-expr : Exp]
         [method-name : Symbol]
         [arg-expr : Exp]))

(define-type Value
  (numV [n : Number])
  (objV [fields : (Listof (Symbol * Value))]
        [methods : (Listof (Symbol * Exp))]))

(module+ test
  (print-only-errors #t))

;; ----------------------------------------

(define (find [l : (Listof (Symbol * 'a))] [name : Symbol]) : 'a
  (type-case (Listof (Symbol * 'a)) l
    [empty
     (error 'find (string-append "not found: " (symbol->string name)))]
    [(cons p rst-l)
     (if (symbol=? (fst p) name)
         (snd p)
         (find rst-l name))]))

(module+ test
  (test (find (list (values 'a 1)) 'a)
        1)
  (test (find (list (values 'a 1) (values 'b 2)) 'b)
        2)
  (test/exn (find empty 'a)
            "not found: a")
  (test/exn (find (list (values 'a 1)) 'x)
            "not found: x"))

;; ----------------------------------------

(define interp : (Exp Value Value -> Value)
  (lambda (a this-val arg-val)
    (type-case Exp a
      [(numE n) (numV n)]
      [(plusE l r) (num+ (interp l this-val arg-val) 
                         (interp r this-val arg-val))]
      [(multE l r) (num* (interp l this-val arg-val) 
                         (interp r this-val arg-val))]
      [(thisE) this-val]
      [(argE) arg-val]
      [(objectE fields methods)
       (objV (map (lambda (f)
                    (let ([name (fst f)]
                          [exp (snd f)])
                      (values name (interp exp this-val arg-val))))
                  fields)
             methods)]
      [(getE obj-expr field-name)
       (let ([thisObj (interp obj-expr this-val arg-val)])
         (type-case Value thisObj
           [(objV fields methods)
            (try (find fields field-name)
                 (lambda () (interp (find methods field-name)
                                    thisObj
                                    (numV 0))))]
           [else (error 'interp "not an object")]))]
      [(sendE obj-expr method-name arg-expr)
       (local [(define obj (interp obj-expr this-val arg-val))
               (define next-arg-val (interp arg-expr this-val arg-val))]
         (type-case Value obj
           [(objV fields methods)
            (let ([body-expr (find methods method-name)])
              (interp body-expr
                      obj
                      next-arg-val))]
           [else (error 'interp "not an object")]))])))

(define (num-op [op : (Number Number -> Number)]
                [op-name : Symbol] 
                [x : Value]
                [y : Value]) : Value
  (cond
    [(and (numV? x) (numV? y))
     (numV (op (numV-n x) (numV-n y)))]
    [else (error 'interp "not a number")]))

(define (num+ x y) (num-op + '+ x y))
(define (num* x y) (num-op * '* x y))

;; ----------------------------------------
;; Examples

(module+ test
  (define posn27
    (objectE
     (list (values 'x (numE 2))
           (values 'y (numE 7)))
     (list (values 'mdist
                   (plusE (getE (thisE) 'x) (getE (thisE) 'y)))
           (values 'addX
                   (plusE (getE (thisE) 'x) (argE)))
           (values 'multY (multE (argE) (getE (thisE) 'y))))))

  (define posn531
    (objectE
     (list (values 'x (numE 5))
           (values 'y (numE 3))
           (values 'z (numE 1)))
     (list (values 'mdist (plusE (getE (thisE) 'z)
                                 (plusE (getE (thisE) 'x) (getE (thisE) 'y))))))))

;; ----------------------------------------

(module+ test
  (test (interp (numE 10) 
                (objV empty empty) (numV 0))
        (numV 10))
  (test (interp (plusE (numE 10) (numE 17))
                (objV empty empty) (numV 0))
        (numV 27))
  (test (interp (multE (numE 10) (numE 7))
                (objV empty empty) (numV 0))
        (numV 70))
  (test (interp (objectE (list (values 'a (numE 1))
                               (values 'b (numE 2)))
                         (list (values 'm (numE 0))))
                (objV empty empty) (numV 0))
        (objV (list (values 'a (numV 1))
                    (values 'b (numV 2)))
              (list (values 'm (numE 0)))))
  
  (test (interp (sendE posn27 'mdist (numE 0))
                (objV empty empty) (numV 0))
        (numV 9))
  
  (test (interp (sendE posn27 'addX (numE 10))
                (objV empty empty) (numV 0))
        (numV 12))
  
  (test/exn (interp (plusE (numE 1) (objectE empty empty))
                    (objV empty empty) (numV 0))
            "not a number")
  (test/exn (interp (getE (numE 1) 'x)
                    (objV empty empty) (numV 0))
            "not an object")
  (test/exn (interp (sendE (numE 1) 'mdist (numE 0))
                    (objV empty empty) (numV 0))
            "not an object")
  (test (interp (getE (objectE (list) ;;no field m
                               (list (values 'm ;;we want to get the method instead
                                             (plusE (numE 1) (numE 2)))))
                      'm)
                (objV empty empty)
                (numV 0))
        (numV 3)))
                
                
______________

__Notes__

(define (numV n)
	(list (values 'apply (lambda (arg-val ...))
		  (values 'number (lambda () ...)))))

(dfine (closV n body c-env)
	(list (values 'appy (lambda (arg-val) ...))
		  (values 'number (lambda () ...))))

results of numV or closV is an object.

fucntions for 'apply and 'number are methods.

n, body, c-env are feilds.

numV and closV are constructors.

Moving to Classes provides two new features
	- inheritance of methonds
	- static method despatch (using super to invoke method in parent class)

Flattening cuts out the inheritence by putting all the relevenat infomarion into each class.


Classes *************************************************************

__Class Demo__

#lang plait

(define-type Exp
  (numE [n : Number])
  (plusE [lhs : Exp]
         [rhs : Exp])
  (multE [lhs : Exp]
         [rhs : Exp])
  (absE [itm : Exp])
  (argE)
  (thisE)
  (newE [class-name : Symbol]
        [args : (Listof Exp)])
  (getE [obj-expr : Exp]
        [field-name : Symbol])
  (sgetE [class-name : Symbol]
         [obj-expr : Exp]
         [field-name : Symbol])
  (sendE [obj-expr : Exp]
         [method-name : Symbol]
         [arg-expr : Exp])
  (ssendE [obj-expr : Exp]
          [class-name : Symbol]
          [method-name : Symbol]
          [arg-expr : Exp]))

(define-type Class
  (classC [field-names : (Listof Symbol)]
          [methods : (Listof (Symbol * Exp))]))

(define-type Value
  (numV [n : Number])
  (objV [class-name : Symbol]
        [field-values : (Listof Value)]))

(module+ test
  (print-only-errors #t))

;; ----------------------------------------

(define (find [l : (Listof (Symbol * 'a))] [name : Symbol]) : 'a
  (type-case (Listof (Symbol * 'a)) l
    [empty
     (error 'find (string-append "not found: " (symbol->string name)))]
    [(cons p rst-l)
     (if (symbol=? (fst p) name)
         (snd p)
         (find rst-l name))]))

(module+ test
  (test (find (list (values 'a 1)) 'a)
        1)
  (test (find (list (values 'a 1) (values 'b 2)) 'b)
        2)
  (test/exn (find empty 'a)
            "not found: a")
  (test/exn (find (list (values 'a 1)) 'x)
            "not found: x"))

;; ----------------------------------------

(define interp : (Exp (Listof (Symbol * Class)) Value Value -> Value)
  (lambda (a classes this-val arg-val)
    (local [(define (recur expr)
              (interp expr classes this-val arg-val))]
      (type-case Exp a
        [(numE n) (numV n)]
        [(plusE l r) (num+ (recur l) (recur r))]
        [(multE l r) (num* (recur l) (recur r))]
        [(absE i) (type-case Value (recur i)
                    [(numV n)
                     (if (> n 0)
                         (numV n)
                         (num* (numV n) (numV -1)))]
                    [else (error 'interp "not a number")])]
        [(thisE ) this-val]
        [(argE ) arg-val]
        [(newE class-name field-exprs)
         (local [(define c (find classes class-name))
                 (define vals (map recur field-exprs))]
           (if (= (length vals) (length (classC-field-names c)))
               (objV class-name vals)
               (error 'interp "wrong field count")))]
        [(getE obj-expr field-name)
         (type-case Value (recur obj-expr)
           [(objV class-name field-vals)
            (type-case Class (find classes class-name)
              [(classC field-names methods)
               (find (map2 (lambda (n v) (values n v))
                           field-names
                           field-vals)
                     field-name)])]
           [else (error 'interp "not an object")])]
        [(sgetE class-name obj-expr field-name) ;Symbol Exp Symbol
         (type-case Value (recur obj-expr)
           [(objV o-class-name field-vals)
            (type-case Class (find classes class-name)
              [(classC field-names methods)
               (find (reverse
                      (map2/stop-early (lambda (n v) (values n v))
                                       field-names
                                       field-vals))
                     field-name)])]
           [else (error 'interp "not an object")])]
        [(sendE obj-expr method-name arg-expr)
         (local [(define obj (recur obj-expr))
                 (define arg-val (recur arg-expr))]
           (type-case Value obj
             [(objV class-name field-vals)
              (call-method class-name method-name classes
                           obj arg-val)]
             [else (error 'interp "not an object")]))]
        [(ssendE obj-expr class-name method-name arg-expr)
         (local [(define obj (recur obj-expr))
                 (define arg-val (recur arg-expr))]
           (call-method class-name method-name classes
                        obj arg-val))]))))

(define (call-method class-name method-name classes
                     obj arg-val)
  (type-case Class (find classes class-name)
    [(classC field-names methods)
     (let ([body-expr (find methods method-name)])
       (interp body-expr
               classes
               obj
               arg-val))]))

(define (num-op [op : (Number Number -> Number)]
                [op-name : Symbol] 
                [x : Value]
                [y : Value]) : Value
  (cond
    [(and (numV? x) (numV? y))
     (numV (op (numV-n x) (numV-n y)))]
    [else (error 'interp "not a number")]))

(define (num+ x y) (num-op + '+ x y))
(define (num* x y) (num-op * '* x y))

(define (map2/stop-early proc l1 l2)
  (cond
    [(empty? l1) empty]
    [(empty? l2) empty]
    [else (cons (proc (first l1)
                      (first l2))
                (map2/stop-early proc (rest l1) (rest l2)))]))

;; ----------------------------------------
;; Examples

(module+ test
  (define posn-class
    (values 'Posn
            (classC 
             (list 'x 'y)
             (list (values 'mdist
                           (plusE (getE (thisE) 'x) (getE (thisE) 'y)))
                   (values 'addDist
                           (plusE (sendE (thisE) 'mdist (numE 0))
                                  (sendE (argE) 'mdist (numE 0))))
                   (values 'addX
                           (plusE (getE (thisE) 'x) (argE)))
                   (values 'multY (multE (argE) (getE (thisE) 'y)))
                   (values 'factory12 (newE 'Posn (list (numE 1) (numE 2))))))))
    
  (define posn3D-class
    (values 'Posn3D
            (classC 
             (list 'x 'y 'z)
             (list (values 'mdist (plusE (getE (thisE) 'z)
                                         (ssendE (thisE) 'Posn 'mdist (argE))))
                   (values 'addDist (ssendE (thisE) 'Posn 'addDist (argE)))))))

  (define posn27 (newE 'Posn (list (numE 2) (numE 7))))
  (define posn531 (newE 'Posn3D (list (numE 5) (numE 3) (numE 1))))

  (define (interp-posn a)
    (interp a (list posn-class posn3D-class) (numV -1) (numV -1))))

;; ----------------------------------------

(module+ test
  (test (interp (numE 10) 
                empty (objV 'Object empty) (numV 0))
        (numV 10))
  (test (interp (plusE (numE 10) (numE 17))
                empty (objV 'Object empty) (numV 0))
        (numV 27))
  (test (interp (absE (numE -10))
                empty (objV 'Object empty) (numV 0))
        (numV 10))
  (test (interp (multE (numE 10) (numE 7))
                empty (objV 'Object empty) (numV 0))
        (numV 70))

  (test (interp-posn (newE 'Posn (list (numE 2) (numE 7))))
        (objV 'Posn (list (numV 2) (numV 7))))

  (test (interp-posn (sendE posn27 'mdist (numE 0)))
        (numV 9))
  
  (test (interp-posn (sendE posn27 'addX (numE 10)))
        (numV 12))

  (test (interp-posn (sendE (ssendE posn27 'Posn 'factory12 (numE 0))
                            'multY
                            (numE 15)))
        (numV 30))

  (test (interp-posn (sendE posn531 'addDist posn27))
        (numV 18))
  
  (test/exn (interp-posn (plusE (numE 1) posn27))
            "not a number")
  (test/exn (interp-posn (getE (numE 1) 'x))
            "not an object")
  (test/exn (interp-posn (sendE (numE 1) 'mdist (numE 0)))
            "not an object")
  (test/exn (interp-posn (ssendE (numE 1) 'Posn 'mdist (numE 0)))
            "not an object")
  (test/exn (interp-posn (newE 'Posn (list (numE 0))))
            "wrong field count"))


#lang plait ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(require "class.rkt"
         "inherit.rkt")

;; Add {neg <expr>} to negate the number
;; produced by <expr>

;; Add {sget <class-name> <expr> <field-name>} to
;; be analogous to `(<class-name><expr>).<field-name>` in Java
;; to get shadowed fields

(module+ test
  (print-only-errors #t))

;; ----------------------------------------

(define (parse-class [s : S-Exp]) : (Symbol * ClassI)
  (cond
    [(s-exp-match? `{class SYMBOL extends SYMBOL {ANY ...} ANY ...} s)
     (values (s-exp->symbol (second (s-exp->list s)))
             (classI
              (s-exp->symbol (fourth (s-exp->list s)))
              (map parse-field
                   (s-exp->list (fourth (rest (s-exp->list s)))))
              (map parse-method 
                   (rest (rest (rest (rest (rest (s-exp->list s)))))))))]
   [else (error 'parse-class "invalid input")]))

(define (parse-field [s : S-Exp]) : Symbol
  (cond
   [(s-exp-match? `SYMBOL s)
    (s-exp->symbol s)]
   [else (error 'parse-field "invalid input")]))

(define (parse-method [s : S-Exp]) : (Symbol * ExpI)
  (cond
   [(s-exp-match? `[SYMBOL {arg} ANY] s)
    (values (s-exp->symbol (first (s-exp->list s)))
            (parse (third (s-exp->list s))))]
   [else (error 'parse-method "invalid input")]))

(define (parse [s : S-Exp]) : ExpI
  (cond
   [(s-exp-match? `NUMBER s) (numI (s-exp->number s))]
   [(s-exp-match? `arg s) (argI)]
   [(s-exp-match? `this s) (thisI)]
   [(s-exp-match? `{+ ANY ANY} s)
    (plusI (parse (second (s-exp->list s)))
           (parse (third (s-exp->list s))))]
   [(s-exp-match? `{abs ANY} s)
    (absI (parse (second (s-exp->list s))))]
   [(s-exp-match? `{* ANY ANY} s)
    (multI (parse (second (s-exp->list s)))
           (parse (third (s-exp->list s))))]
   [(s-exp-match? `{new SYMBOL ANY ...} s)
    (newI (s-exp->symbol (second (s-exp->list s)))
          (map parse (rest (rest (s-exp->list s)))))]
   [(s-exp-match? `{get ANY SYMBOL} s)
    (getI (parse (second (s-exp->list s)))
          (s-exp->symbol (third (s-exp->list s))))]
   [(s-exp-match? `{sget SYMBOL ANY SYMBOL} s)
    (sgetI (s-exp->symbol (second (s-exp->list s)))
           (parse (third (s-exp->list s)))
           (s-exp->symbol (fourth (s-exp->list s))))]
   [(s-exp-match? `{send ANY SYMBOL ANY} s)
    (sendI (parse (second (s-exp->list s)))
           (s-exp->symbol (third (s-exp->list s)))
           (parse (fourth (s-exp->list s))))]
   [(s-exp-match? `{super SYMBOL ANY} s)
    (superI (s-exp->symbol (second (s-exp->list s)))
            (parse (third (s-exp->list s))))]
   [else (error 'parse "invalid input")]))

(module+ test
  (test (parse `0)
        (numI 0))
  (test (parse `arg)
        (argI))
  (test (parse `this)
        (thisI))
  (test (parse `{+ 1 2})
        (plusI (numI 1) (numI 2)))
  (test (parse `{* 1 2})
        (multI (numI 1) (numI 2)))
  (test (parse `{new Posn 1 2})
        (newI 'Posn (list (numI 1) (numI 2))))
  (test (parse `{get 1 x})
        (getI (numI 1) 'x))
  (test (parse `{send 1 m 2})
        (sendI (numI 1) 'm (numI 2)))
  (test (parse `{super m 1})
        (superI 'm (numI 1)))
  (test/exn (parse `x)
            "invalid input")

  (test (parse-field `x)
        'x)
  (test/exn (parse-field `{x 1})
            "invalid input")

  (test (parse-method `[m {arg} this])
        (values 'm (thisI)))
  (test/exn (parse-method `[m {arg} 1 2])
            "invalid input")
  
  (test (parse-class `{class Posn3D extends Posn
                        {x y z}
                        [m1 {arg} arg]
                        [m2 {arg} this]})
        (values 'Posn3D
                (classI 'Posn
                        (list 'x 'y 'z)
                        (list (values 'm1 (argI))
                              (values 'm2 (thisI))))))
  (test/exn (parse-class `{class})
            "invalid input"))

;; ----------------------------------------

(define (interp-prog [classes : (Listof S-Exp)] [a : S-Exp]) : S-Exp
  (let ([v (interp-i (parse a)
                     (map parse-class classes))])
    (type-case Value v
      [(numV n) (number->s-exp n)]
      [(objV class-name field-vals) `object])))

(module+ test
  (test (interp-prog
         (list
          `{class Empty extends Object
             {}})
         `{new Empty})
        `object)

 (test (interp-prog 
        (list
         `{class Posn extends Object
            {x y}
            [mdist {arg} {+ {get this x} {get this y}}]
            [addDist {arg} {+ {send arg mdist 0}
                              {send this mdist 0}}]}
         
         `{class Posn3D extends Posn
            {z}
            [mdist {arg} {+ {get this z} 
                            {super mdist arg}}]})
        
        `{send {new Posn3D 5 3 1} addDist {new Posn {abs -2} 7}})
       `18)

  (test (interp-prog 
        (list
         `{class Posn extends Object
            {x y}
            [mdist {arg} {+ {sget Posn this x} {sget Posn this y}}]
            [addDist {arg} {+ {send arg mdist 0}
                              {send this mdist 0}}]}
         
         `{class Posn3D extends Posn
            {x z}
            [mdist {arg} {+ {sget Posn3D this x}
                            {+ {sget Posn3D this z} 
                               {super mdist arg}}}]})
        
        `{send {new Posn3D 5 3 1 2} addDist {new Posn {abs -2} 7}})
       `20))

#|

`{class Posn
   {x y}
   [mdist {arg} {+ {get this x} {get this y}}]
   [addDist {arg} {+ {send arg mdist 0}
                     {send this mdist 0}}]}
         
`{class Posn3D
   {x y z}
   [mdist {arg} {+ {get this z} 
                   {ssend Posn mdist arg}}]
   [addDist {arg} {+ {send arg mdist 0}
                     {send this mdist 0}}]}

|#


#lang plait ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Make all "class.rkt" definitions available here, where
;; the "class.rkt" file must be in the same directory
;; as this one:
(require "class.rkt")

(define-type ExpI
  (numI [n : Number])
  (plusI [lhs : ExpI]
         [rhs : ExpI])
  (multI [lhs : ExpI]
         [rhs : ExpI])
  (absI  [i : ExpI])
  (argI)
  (thisI)
  (newI [class-name : Symbol]
        [args : (Listof ExpI)])
  (getI [obj-expr : ExpI]
        [field-name : Symbol])
  (sgetI [class-name : Symbol]
         [obj-expr : ExpI]
         [field-name : Symbol])
  (sendI [obj-expr : ExpI]
         [method-name : Symbol]
         [arg-expr : ExpI])
  (superI [method-name : Symbol]
          [arg-expr : ExpI]))

(define-type ClassI
  (classI [super-name : Symbol]
          [field-names : (Listof Symbol)]
          [methods : (Listof (Symbol * ExpI))]))

(module+ test
  (print-only-errors #t))

;; ----------------------------------------

(define (exp-i->c [a : ExpI] [super-name : Symbol]) : Exp
  (local [(define (recur expr)
            (exp-i->c expr super-name))]
    (type-case ExpI a
      [(numI n) (numE n)]
      [(plusI l r) (plusE (recur l) (recur r))]
      [(multI l r) (multE (recur l) (recur r))]
      [(absI i) (absE (recur i))]
      [(argI) (argE)]
      [(thisI) (thisE)]
      [(newI class-name field-exprs)
       (newE class-name (map recur field-exprs))]
      [(getI expr field-name)
       (getE (recur expr) field-name)]
      [(sgetI class-name expr field-name)
       (sgetE class-name (recur expr) field-name)]
      [(sendI expr method-name arg-expr)
       (sendE (recur expr)
              method-name
              (recur arg-expr))]
      [(superI method-name arg-expr)
       (ssendE (thisE)
               super-name
               method-name
               (recur arg-expr))])))

(module+ test
  (test (exp-i->c (absI (numI -10)) 'Object)
        (absE (numE -10)))
  (test (exp-i->c (numI 10) 'Object)
        (numE 10))
  (test (exp-i->c (plusI (numI 10) (numI 2)) 'Object)
        (plusE (numE 10) (numE 2)))
  (test (exp-i->c (multI (numI 10) (numI 2)) 'Object)
        (multE (numE 10) (numE 2)))
  (test (exp-i->c (argI) 'Object)
        (argE))
  (test (exp-i->c (thisI) 'Object)
        (thisE))
  (test (exp-i->c (newI 'Object (list (numI 1))) 'Object)
        (newE 'Object (list (numE 1))))
  (test (exp-i->c (getI (numI 1) 'x) 'Object)
        (getE (numE 1) 'x))
  (test (exp-i->c (sendI (numI 1) 'mdist (numI 2)) 'Object)
        (sendE (numE 1) 'mdist (numE 2)))
  (test (exp-i->c (superI 'mdist (numI 2)) 'Posn)
        (ssendE (thisE) 'Posn 'mdist (numE 2))))

;; ----------------------------------------

(define (class-i->c-not-flat [c : ClassI]) : Class
  (type-case ClassI c
    [(classI super-name field-names methods)
     (classC
      field-names
      (map (lambda (m)
             (values (fst m)
                     (exp-i->c (snd m) super-name)))
           methods))]))

(module+ test
  (define posn3d-mdist-i-method
    (values 'mdist
            (plusI (getI (thisI) 'z)
                   (superI 'mdist (argI)))))
  (define posn3d-mdist-c-method
    (values 'mdist
            (plusE (getE (thisE) 'z)
                   (ssendE (thisE) 'Posn 'mdist (argE)))))

  (define posn3d-i-class 
    (values 'Posn3D
            (classI
             'Posn
             (list 'z)
             (list posn3d-mdist-i-method))))
  (define posn3d-c-class-not-flat
    (values 'Posn3D
            (classC (list 'z)
                    (list posn3d-mdist-c-method))))

  (test (class-i->c-not-flat (snd posn3d-i-class))
        (snd posn3d-c-class-not-flat)))

;; ----------------------------------------

(define (flatten-class [name : Symbol]
                       [classes-not-flat : (Listof (Symbol * Class))] 
                       [i-classes : (Listof (Symbol * ClassI))]) : Class
  (type-case Class (find classes-not-flat name)
    [(classC field-names methods)
     (type-case Class (flatten-super name classes-not-flat i-classes)
       [(classC super-field-names super-methods)
        (classC
         (add-fields super-field-names field-names)
         (add/replace-methods super-methods methods))])]))

(define (flatten-super [name : Symbol]
                       [classes-not-flat : (Listof (Symbol * Class))] 
                       [i-classes : (Listof (Symbol * ClassI))]) : Class
  (type-case ClassI (find i-classes name)
    [(classI super-name field-names i-methods)
     (if (equal? super-name 'Object)
         (classC empty empty)
         (flatten-class super-name
                        classes-not-flat
                        i-classes))]))

(module+ test
  (define posn-i-class
    (values
     'Posn
     (classI 'Object
             (list 'x 'y)
             (list (values 'mdist
                           (plusI (getI (thisI) 'x)
                                  (getI (thisI) 'y)))
                   (values 'addDist
                            (plusI (sendI (thisI) 'mdist (numI 0))
                                   (sendI (argI) 'mdist (numI 0))))))))
  (define addDist-c-method
    (values 'addDist
            (plusE (sendE (thisE) 'mdist (numE 0))
                   (sendE (argE) 'mdist (numE 0)))))
  (define posn-c-class-not-flat
    (values
     'Posn
    (classC (list 'x 'y)
            (list (values 'mdist
                          (plusE (getE (thisE) 'x)
                                 (getE (thisE) 'y)))
                  addDist-c-method))))
  (define posn3d-c-class
    (values 'Posn3D
            (classC (list 'x 'y 'z)
                    (list posn3d-mdist-c-method
                          addDist-c-method))))

  (test (flatten-class 'Posn3D
                       (list posn-c-class-not-flat
                             posn3d-c-class-not-flat)
                       (list posn-i-class
                             posn3d-i-class))
        (snd posn3d-c-class)))

;; ----------------------------------------

(define add-fields append)

(define (add/replace-methods [methods : (Listof (Symbol * Exp))]
                             [new-methods : (Listof (Symbol * Exp))])
  : (Listof (Symbol * Exp))
  (cond
    [(empty? new-methods) methods]
    [else (add/replace-methods
           (add/replace-method methods (first new-methods))
           (rest new-methods))]))

(define (add/replace-method [methods : (Listof (Symbol * Exp))] 
                            [new-method : (Symbol * Exp)])
  : (Listof (Symbol * Exp))
  (cond
    [(empty? methods) (list new-method)]
    [else
     (if (equal? (fst (first methods))
                 (fst new-method))
         (cons new-method (rest methods))
         (cons (first methods) 
               (add/replace-method (rest methods)
                                   new-method)))]))

(module+ test
  (test (add-fields (list 'x 'y) (list 'z))
        (list 'x 'y 'z))

  (test (add/replace-methods empty empty)
        empty)
  (test (add/replace-methods empty (list (values 'm (numE 0))))
        (list (values 'm (numE 0))))
  (test (add/replace-methods (list (values 'm (numE 0))) empty)
        (list (values 'm (numE 0))))
  (test (add/replace-methods (list (values 'm (numE 0)))
                             (list (values 'm (numE 1))))
        (list (values 'm (numE 1))))
  (test (add/replace-methods (list (values 'm (numE 0))
                                   (values 'n (numE 2)))
                             (list (values 'm (numE 1))))
        (list (values 'm (numE 1))
              (values 'n (numE 2))))
  (test (add/replace-methods (list (values 'm (numE 0)))
                             (list (values 'm (numE 1))
                                   (values 'n (numE 2))))
        (list (values 'm (numE 1))
              (values 'n (numE 2))))

  (test (add/replace-method (list (values 'm (numE 0)))
                            (values 'm (numE 1)))
        (list (values 'm (numE 1))))
  (test (add/replace-method (list (values 'm (numE 0)))
                            (values 'n (numE 2)))
        (list (values 'm (numE 0))
              (values 'n (numE 2)))))

;; ----------------------------------------

(define (interp-i [i-a : ExpI] [i-classes : (Listof (Symbol * ClassI))]) : Value
  (local [(define a (exp-i->c i-a 'Object))
          (define classes-not-flat
            (map (lambda (i)
                   (values (fst i)
                           (class-i->c-not-flat (snd i))))
                 i-classes))
          (define classes
            (map (lambda (c)
                   (let ([name (fst c)])
                     (values name
                             (flatten-class name classes-not-flat i-classes))))
                 classes-not-flat))]
    (interp a classes (objV 'Object empty) (numV 0))))

(module+ test
  (test (interp-i (numI 0) empty)
        (numV 0))

  (test (interp-i
         (sendI (newI 'Posn3D (list (numI 5) (numI 3) (numI 1)))
                'addDist
                (newI 'Posn (list (numI 2) (numI 7))))
         (list posn-i-class
               posn3d-i-class))
        (numV 18)))


______________

__Notes__






Types *************************************************************

__Class Demo__

______________

__Notes__










